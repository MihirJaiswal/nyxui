import { exec } from "child_process";
import { promises as fs } from "fs";
import path from "path";
import { rimraf } from "rimraf";
import { registryItemSchema, type Registry } from "shadcn/registry";
import { z } from "zod";

import { examples } from "../registry/registry-examples";
import { lib } from "../registry/registry-lib";
import { ui } from "../registry/registry-ui";

// Helper function to normalize paths (always use forward slashes)
function normalizePath(filePath: string): string {
  return filePath.replace(/\\/g, '/');
}

// Helper function to normalize paths in registry items
function normalizeRegistryItem(item: any): any {
  if (!item.files) return item;
  
  return {
    ...item,
    files: item.files.map((file: any) => {
      if (typeof file === 'string') {
        return normalizePath(file);
      }
      return {
        ...file,
        path: normalizePath(file.path),
        target: file.target ? normalizePath(file.target) : file.target
      };
    })
  };
}

const DEPRECATED_ITEMS = ["toast"];

console.log("ğŸ” Loaded registry-ui items:", ui.map((i) => i.name));
console.log("ğŸ” Loaded registry-examples items:", examples.map((i) => i.name));
console.log("ğŸ” Loaded registry-lib items:", lib.map((i) => i.name));

// Normalize all paths before creating the registry
const normalizedUi = ui.map(normalizeRegistryItem);
const normalizedExamples = examples.map(normalizeRegistryItem);
const normalizedLib = lib.map(normalizeRegistryItem);

const registry = {
  name: "shadcn/ui",
  homepage: "https://ui.shadcn.com",
  items: z
    .array(registryItemSchema)
    .parse(
      [
        {
          name: "index",
          type: "registry:style",
          dependencies: [
            "tw-animate-css",
            "class-variance-authority",
            "lucide-react",
          ],
          registryDependencies: ["utils"],
          cssVars: {},
          files: [],
        },
        ...normalizedUi,
        ...normalizedExamples,
        ...normalizedLib,
      ].filter((item) => !DEPRECATED_ITEMS.includes(item.name))
    ),
} satisfies Registry;

console.log("âœ… Total registry items after filter:", registry.items.length);

async function buildRegistryIndex() {
  console.log("ğŸ—‚ï¸ Starting buildRegistryIndex()");
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`;

  for (const item of registry.items) {
    console.log(`  â€£ INDEX: processing item "${item.name}" (type: ${item.type})`);
    if (!item.files || item.files.length === 0) {
      console.log(`    â€“ skipping "${item.name}" because it has no files`);
      continue;
    }

    console.log(
      `    â€“ files:`,
      item.files.map((f) => f.path)
    );

    const componentPath = item.files[0].path ? `@/${item.files[0].path}` : "";

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ""}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [${item.files
      .map((file) => {
        const filePath = normalizePath(`${typeof file === "string" ? file : file.path}`);
        const resolvedFilePath = normalizePath(path.resolve(filePath));
        return typeof file === "string"
          ? `"${resolvedFilePath}"`
          : `{
      path: "${filePath}",
      type: "${file.type}",
    }`;
      })
      .join(", ")}],
    component: ${
      componentPath
        ? `React.lazy(async () => {
      const mod = await import("${componentPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || item.name
      return { default: mod.default || mod[exportName] }
    })`
        : "null"
    },
    meta: ${JSON.stringify(item.meta)},
  },`;
  }

  index += `
  }`;

  const outPath = path.join(process.cwd(), "__registry__/index.tsx");
  console.log("âœï¸ Writing __registry__/index.tsx to", outPath);
  rimraf.sync(outPath);
  await fs.writeFile(outPath, index);
  console.log("âœ… buildRegistryIndex() complete");
}

async function buildRegistryJsonFile() {
  console.log("ğŸ’… Starting buildRegistryJsonFile()");
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => ({
      ...item,
      files: item.files?.map((file) => ({
        ...file,
        path: normalizePath(`${file.path}`),
        target: file.target ? normalizePath(file.target) : file.target
      })),
    })),
  };

  const rootJson = path.join(process.cwd(), `registry.json`);
  const publicJson = path.join(process.cwd(), `public/registry.json`);
  console.log("  â€“ Removing old registry.json");
  rimraf.sync(rootJson);
  rimraf.sync(publicJson);

  const registryJson = JSON.stringify(fixedRegistry, null, 2);
  console.log("  â€“ Writing new registry.json to", rootJson);
  await fs.writeFile(rootJson, registryJson);
  console.log("  â€“ Writing new registry.json to", publicJson);
  await fs.writeFile(publicJson, registryJson);
  console.log("âœ… buildRegistryJsonFile() complete");
}

async function buildRegistry() {
  console.log("ğŸ—ï¸ Starting pnpm shadcn:build");
  return new Promise<void>((resolve, reject) => {
    const child = exec(`pnpm shadcn registry:build --verbose`, (err, stdout, stderr) => {
      console.log("--- shadcn:build stdout ---");
      console.log(stdout);
      console.log("=== shadcn:build stderr ===");
      console.error(stderr);

      if (err) {
        console.error("âŒ shadcn:build error:", err);
        reject(err);
      } else {
        console.log("âœ… shadcn:build completed successfully");
        resolve();
      }
    });
  });
}

// Helper function to deduplicate files in a registry item
function deduplicateItemFiles(item) {
  if (!item.files || item.files.length === 0) {
    return { ...item, files: [] };
  }
  
  const normalizedFiles = new Map();
  
  (item.files || []).forEach(file => {
    let normalizedPath;
    let fileObj;
    
    if (typeof file === 'string') {
      normalizedPath = normalizePath(file);
      fileObj = normalizedPath; 
    } else {
      normalizedPath = normalizePath(file.path);
      fileObj = {
        ...file,
        path: normalizedPath,
        target: file.target ? normalizePath(file.target) : file.target
      };
    }
    
    const existingFile = normalizedFiles.get(normalizedPath);
    if (!existingFile || (file.content && (!existingFile.content || existingFile.target === ''))) {
      normalizedFiles.set(normalizedPath, fileObj);
    }
  });
  return {
    ...item,
    files: Array.from(normalizedFiles.values())
  };
}

async function fixRegistryJson() {
  console.log("ğŸ”§ Starting improved fixRegistryJson()");
  const publicRJson = path.join(process.cwd(), `public/r/registry.json`);
  const publicRDir = path.join(process.cwd(), `public/r`);
  
  try {
    // Read the generated registry.json
    console.log(`  â€“ Reading registry.json from ${publicRJson}`);
    const registryJsonContent = await fs.readFile(publicRJson, 'utf8');
    const registryData = JSON.parse(registryJsonContent);
    
    console.log(`  â€“ Original registry.json has ${registryData.items.length} items`);
    
    const uniqueItemsByName = new Map();
    
    for (const item of registryData.items) {
      const itemName = item.name;
      
      // Skip items with no files
      if (!item.files || item.files.length === 0) {
        if (!uniqueItemsByName.has(itemName)) {
          uniqueItemsByName.set(itemName, { ...item, files: [] });
        }
        continue;
      }
      
      const itemWithDedupedFiles = deduplicateItemFiles(item);
      
      if (uniqueItemsByName.has(itemName)) {
        const existingItem = uniqueItemsByName.get(itemName);
        const existingFilesMap = new Map();
        
        (existingItem.files || []).forEach(file => {
          const path = typeof file === 'string' ? file : file.path;
          existingFilesMap.set(path, file);
        });
        
        (itemWithDedupedFiles.files || []).forEach(file => {
          const path = typeof file === 'string' ? file : file.path;
          if (!existingFilesMap.has(path)) {
            existingFilesMap.set(path, file);
          }
        });
        
        uniqueItemsByName.set(itemName, {
          ...existingItem,
          files: Array.from(existingFilesMap.values())
        });
      } else {
        uniqueItemsByName.set(itemName, itemWithDedupedFiles);
      }
    }
    
    const dedupedItems = Array.from(uniqueItemsByName.values());
    
    registryData.items = dedupedItems;
    
    let totalFiles = 0;
    dedupedItems.forEach(item => {
      const fileCount = item.files ? item.files.length : 0;
      totalFiles += fileCount;
      console.log(`  â€“ Item "${item.name}" has ${fileCount} unique files`);
    });
    
    console.log(`  â€“ After deduplication: ${dedupedItems.length} unique items with ${totalFiles} total files`);
    
    console.log(`  â€“ Writing fixed registry.json to ${publicRJson}`);
    await fs.writeFile(publicRJson, JSON.stringify(registryData, null, 2));
    
    const publicJson = path.join(process.cwd(), `public/registry.json`);
    console.log(`  â€“ Writing fixed registry.json to ${publicJson}`);
    await fs.writeFile(publicJson, JSON.stringify(registryData, null, 2));
    
    console.log("  â€“ Fixing individual component JSON files in public/r directory");
    try {
      const files = await fs.readdir(publicRDir);
      let fixedComponentsCount = 0;
      
      for (const file of files) {
        if (file.endsWith('.json') && file !== 'registry.json') {
          const componentPath = path.join(publicRDir, file);
          console.log(`    âˆ™ Processing component file: ${file}`);
          
          try {
            const componentContent = await fs.readFile(componentPath, 'utf8');
            const componentData = JSON.parse(componentContent);
            
            if (componentData.files && Array.isArray(componentData.files)) {
              const fixedComponent = deduplicateItemFiles(componentData);
              
              if (fixedComponent.files.length !== componentData.files.length) {
                console.log(`    âœ“ Fixed component ${file}: reduced from ${componentData.files.length} to ${fixedComponent.files.length} files`);
                await fs.writeFile(componentPath, JSON.stringify(fixedComponent, null, 2));
                fixedComponentsCount++;
              }
            }
          } catch (err) {
            console.log(`    âœ— Error processing component file ${file}: ${err.message}`);
          }
        }
      }
      
      console.log(`  â€“ Fixed ${fixedComponentsCount} individual component files`);
    } catch (err) {
      console.log(`  â€“ Error reading public/r directory: ${err.message}`);
    }
    
    console.log(`âœ… Fixed registry.json now has ${registryData.items.length} unique items with ${totalFiles} total files`);
  } catch (error) {
    console.error("âŒ Error fixing registry.json:", error);
  }
}

(async () => {
  try {
    console.log("ğŸš€ Build registry started");
    await buildRegistryIndex();
    await buildRegistryJsonFile();
    await buildRegistry();
    await fixRegistryJson();
    console.log("ğŸ All registry build steps completed");
  } catch (error) {
    console.error("âŒ Build failed with error:", error);
    process.exit(1);
  }
})();