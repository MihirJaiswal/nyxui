{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "morphing-blob",
  "type": "registry:ui",
  "title": "Morphing Blob",
  "description": "A morphing blob that that provide several effects.",
  "dependencies": [
    ".."
  ],
  "files": [
    {
      "path": "registry/ui/morphing-blob.tsx",
      "content": "\"use client\";\nimport React, {\n  useRef,\n  useEffect,\n  useState,\n  useMemo,\n  useCallback,\n  useId,\n} from \"react\";\nimport { cn } from \"../../lib/utils\";\n\nexport interface MorphingBlobProps\n  extends React.HTMLAttributes<HTMLDivElement> {\n  theme?:\n    | \"primary\"\n    | \"secondary\"\n    | \"accent\"\n    | \"success\"\n    | \"warning\"\n    | \"danger\"\n    | \"custom\";\n  customColors?: {\n    from: string;\n    via?: string;\n    to: string;\n  };\n  size?: \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n  complexity?: 1 | 2 | 3 | 4 | 5;\n  speed?: 1 | 2 | 3 | 4 | 5;\n  hoverEffect?: boolean;\n  clickEffect?: boolean;\n  pulse?: boolean;\n  glow?: boolean;\n  glowIntensity?: 1 | 2 | 3 | 4 | 5;\n  opacity?: number;\n  smooth?: boolean;\n  effect3D?: boolean;\n  children?: React.ReactNode;\n}\ntype ComplexityFactor = {\n  points: number;\n  variance: number;\n  tension: number;\n};\nconst COMPLEXITY_FACTORS = {\n  1: { points: 6, variance: 0.15, tension: 0.25 },\n  2: { points: 8, variance: 0.25, tension: 0.35 },\n  3: { points: 10, variance: 0.3, tension: 0.4 },\n  4: { points: 12, variance: 0.35, tension: 0.45 },\n  5: { points: 16, variance: 0.4, tension: 0.5 },\n};\n\nconst SPEED_FACTORS = {\n  1: 15000, // Slower\n  2: 12000,\n  3: 9000,\n  4: 6000,\n  5: 3000, // Faster\n};\n\nconst SIZE_CLASSES = {\n  sm: \"w-32 h-32 md:w-40 md:h-40\",\n  md: \"w-48 h-48 md:w-64 md:h-64\",\n  lg: \"w-64 h-64 md:w-80 md:h-80\",\n  xl: \"w-80 h-80 md:w-[32rem] md:h-[32rem]\",\n  full: \"w-full h-full\",\n};\n\nconst GLOW_INTENSITY_CLASSES = {\n  1: \"shadow-sm\",\n  2: \"shadow-md\",\n  3: \"shadow-lg\",\n  4: \"shadow-xl\",\n  5: \"shadow-2xl\",\n};\n\nfunction hexToRgba(hex: string, alpha: number): string {\n  const r = parseInt(hex.slice(1, 3), 16);\n  const g = parseInt(hex.slice(3, 5), 16);\n  const b = parseInt(hex.slice(5, 7), 16);\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\nfunction easeInOutCubic(x: number): number {\n  return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;\n}\n\nfunction isValidNumber(num: number): boolean {\n  return typeof num === \"number\" && !isNaN(num) && isFinite(num);\n}\n\nexport function MorphingBlob({\n  theme = \"primary\",\n  customColors,\n  size = \"md\",\n  complexity = 3,\n  speed = 3,\n  hoverEffect = true,\n  clickEffect = true,\n  pulse = false,\n  glow = true,\n  glowIntensity = 3,\n  opacity = 100,\n  smooth = true,\n  effect3D = false,\n  className,\n  children,\n  ...props\n}: MorphingBlobProps) {\n  const blobRef = useRef<HTMLDivElement>(null);\n  const [isHovered, setIsHovered] = useState(false);\n  const [isClicked, setIsClicked] = useState(false);\n  const [paths, setPaths] = useState({ current: \"\", previous: \"\" });\n  const [rotation, setRotation] = useState(0);\n  const animationRef = useRef<number | null>(null);\n  const previousTimeRef = useRef<number | null>(null);\n  const animationProgress = useRef(0);\n  const instanceId = useId();\n  const gradientId = `blob-gradient-${theme}-${instanceId.replace(/:/g, \"\")}`;\n\n  // Memoize theme colors to prevent recalculation\n  const themeColors = useMemo(\n    () => ({\n      primary: {\n        from: \"#4F46E5\",\n        via: \"#6366F1\",\n        to: \"#818CF8\",\n        glow: \"shadow-indigo-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(99, 102, 241, 0.4))\",\n      },\n      secondary: {\n        from: \"#9333EA\",\n        via: \"#A855F7\",\n        to: \"#C084FC\",\n        glow: \"shadow-purple-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(168, 85, 247, 0.4))\",\n      },\n      accent: {\n        from: \"#0D9488\",\n        via: \"#14B8A6\",\n        to: \"#2DD4BF\",\n        glow: \"shadow-teal-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(20, 184, 166, 0.4))\",\n      },\n      success: {\n        from: \"#16A34A\",\n        via: \"#22C55E\",\n        to: \"#4ADE80\",\n        glow: \"shadow-green-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(34, 197, 94, 0.4))\",\n      },\n      warning: {\n        from: \"#D97706\",\n        via: \"#F59E0B\",\n        to: \"#FBBF24\",\n        glow: \"shadow-amber-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(245, 158, 11, 0.4))\",\n      },\n      danger: {\n        from: \"#DC2626\",\n        via: \"#EF4444\",\n        to: \"#F87171\",\n        glow: \"shadow-red-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(239, 68, 68, 0.4))\",\n      },\n      custom: {\n        from: customColors?.from || \"#000000\",\n        via: customColors?.via || \"#000000\",\n        to: customColors?.to || \"#02001c\",\n        glow: \"shadow-blue-500/40\",\n        filter: `drop-shadow(0 0 10px ${customColors?.from ? hexToRgba(customColors.from, 0.4) : \"rgba(59, 130, 246, 0.4)\"})`,\n      },\n    }),\n    [customColors],\n  );\n\n  const currentTheme = themeColors[theme];\n  const complexityFactor = COMPLEXITY_FACTORS[complexity];\n  const speedValue = SPEED_FACTORS[speed];\n  const generateBlobPath = useCallback(\n    (factor: ComplexityFactor, hover = false, click = false) => {\n      const { points, variance, tension } = factor;\n      const centerX = 50;\n      const centerY = 50;\n      const baseRadius = hover ? 42 : click ? 38 : 40;\n      const angleStep = (Math.PI * 2) / points;\n      const blobPoints = [];\n      for (let i = 0; i < points; i++) {\n        const angle = i * angleStep;\n        const waveVariation =\n          Math.sin(i * 3) * 0.08 +\n          Math.sin(i * 5) * 0.05 +\n          Math.sin(i * 7) * 0.03;\n        const randomVariance =\n          1 - variance + Math.random() * variance * 2 + waveVariation;\n        const radius = Math.max(baseRadius * randomVariance, baseRadius * 0.6);\n\n        blobPoints.push({\n          x: centerX + Math.cos(angle) * radius,\n          y: centerY + Math.sin(angle) * radius,\n        });\n      }\n      let path = `M${blobPoints[0].x},${blobPoints[0].y}`;\n      for (let i = 0; i < points; i++) {\n        const current = blobPoints[i];\n        const next = blobPoints[(i + 1) % points];\n        const prev = blobPoints[(i - 1 + points) % points];\n        const nextNext = blobPoints[(i + 2) % points];\n\n        const cp1x = current.x + (next.x - prev.x) * tension;\n        const cp1y = current.y + (next.y - prev.y) * tension;\n        const cp2x = next.x - (nextNext.x - current.x) * tension;\n        const cp2y = next.y - (nextNext.y - current.y) * tension;\n\n        const validCp1x = isValidNumber(cp1x) ? cp1x : current.x;\n        const validCp1y = isValidNumber(cp1y) ? cp1y : current.y;\n        const validCp2x = isValidNumber(cp2x) ? cp2x : next.x;\n        const validCp2y = isValidNumber(cp2y) ? cp2y : next.y;\n\n        path += ` C${validCp1x},${validCp1y} ${validCp2x},${validCp2y} ${next.x},${next.y}`;\n      }\n\n      return path + \" Z\";\n    },\n    [],\n  );\n  const interpolatePaths = useCallback(\n    (path1: string, path2: string, progress: number) => {\n      if (!path1 || !path2) return path2 || path1 || \"\";\n      const extractPoints = (path: string) => {\n        const regex = /([MC]) ?([^MC]+)/g;\n        const points = [];\n        let match;\n\n        while ((match = regex.exec(path)) !== null) {\n          const [, command, coordStr] = match;\n          const coords = coordStr\n            .trim()\n            .split(/[ ,]/)\n            .filter(Boolean)\n            .map(parseFloat);\n          if (command === \"M\" && coords.length >= 2) {\n            points.push([coords[0], coords[1]]);\n          } else if (command === \"C\" && coords.length >= 6) {\n            points.push([coords[4], coords[5]]);\n          }\n        }\n\n        return points;\n      };\n\n      const points1 = extractPoints(path1);\n      const points2 = extractPoints(path2);\n\n      if (points1.length !== points2.length || points1.length === 0) {\n        return path2;\n      }\n      const easeProgress = easeInOutCubic(progress);\n      const interpolatedPoints = points1.map((point, i) => {\n        if (i < points2.length) {\n          const x = point[0] + (points2[i][0] - point[0]) * easeProgress;\n          const y = point[1] + (points2[i][1] - point[1]) * easeProgress;\n          return [\n            isValidNumber(x) ? x : point[0],\n            isValidNumber(y) ? y : point[1],\n          ];\n        }\n        return point;\n      });\n      let newPath = `M${interpolatedPoints[0][0]},${interpolatedPoints[0][1]}`;\n      const tension = 0.4;\n\n      for (let i = 0; i < interpolatedPoints.length; i++) {\n        const curr = interpolatedPoints[i];\n        const next = interpolatedPoints[(i + 1) % interpolatedPoints.length];\n        const prev =\n          interpolatedPoints[\n            (i - 1 + interpolatedPoints.length) % interpolatedPoints.length\n          ];\n        const nextNext =\n          interpolatedPoints[(i + 2) % interpolatedPoints.length];\n        const cpx1 = curr[0] + (next[0] - prev[0]) * tension;\n        const cpy1 = curr[1] + (next[1] - prev[1]) * tension;\n        const cpx2 = next[0] - (nextNext[0] - curr[0]) * tension;\n        const cpy2 = next[1] - (nextNext[1] - curr[1]) * tension;\n        const validCpx1 = isValidNumber(cpx1) ? cpx1 : curr[0];\n        const validCpy1 = isValidNumber(cpy1) ? cpy1 : curr[1];\n        const validCpx2 = isValidNumber(cpx2) ? cpx2 : next[0];\n        const validCpy2 = isValidNumber(cpy2) ? cpy2 : next[1];\n        newPath += ` C${validCpx1},${validCpy1} ${validCpx2},${validCpy2} ${next[0]},${next[1]}`;\n      }\n\n      return newPath + \" Z\";\n    },\n    [],\n  );\n\n  const animate = useCallback(\n    (time: number) => {\n      if (previousTimeRef.current === null) {\n        previousTimeRef.current = time;\n        animationRef.current = requestAnimationFrame(animate);\n        return;\n      }\n      const deltaTime = time - previousTimeRef.current;\n      const duration = speedValue;\n      animationProgress.current += deltaTime / duration;\n      if (animationProgress.current >= 1) {\n        animationProgress.current = 0;\n        setPaths((prev) => ({\n          previous: prev.current,\n          current: generateBlobPath(complexityFactor, isHovered, isClicked),\n        }));\n\n        setRotation((prev) => (prev + 15 + Math.random() * 30) % 360);\n      }\n\n      previousTimeRef.current = time;\n      animationRef.current = requestAnimationFrame(animate);\n    },\n    [speedValue, complexityFactor, isHovered, isClicked, generateBlobPath],\n  );\n\n  useEffect(() => {\n    if (!paths.current) {\n      const initialPath = generateBlobPath(\n        complexityFactor,\n        isHovered,\n        isClicked,\n      );\n      setPaths({ current: initialPath, previous: initialPath });\n    }\n\n    if (animationRef.current) {\n      cancelAnimationFrame(animationRef.current);\n      animationRef.current = null;\n    }\n    if (smooth) {\n      animationRef.current = requestAnimationFrame(animate);\n      return () => {\n        if (animationRef.current !== null) {\n          cancelAnimationFrame(animationRef.current);\n          animationRef.current = null;\n        }\n      };\n    } else {\n      const interval = setInterval(() => {\n        setPaths((prev) => ({\n          previous: prev.current,\n          current: generateBlobPath(complexityFactor, isHovered, isClicked),\n        }));\n        setRotation((prev) => (prev + 15 + Math.random() * 30) % 360);\n      }, speedValue / 6);\n      return () => clearInterval(interval);\n    }\n  }, [\n    complexity,\n    speed,\n    isHovered,\n    isClicked,\n    smooth,\n    animate,\n    complexityFactor,\n    speedValue,\n    generateBlobPath,\n    paths,\n  ]);\n\n  useEffect(() => {\n    setPaths((prev) => ({\n      previous: prev.current,\n      current: generateBlobPath(complexityFactor, isHovered, isClicked),\n    }));\n    setRotation((prev) => (prev + 15 + Math.random() * 30) % 360);\n    animationProgress.current = 0;\n  }, [isHovered, isClicked, generateBlobPath, complexityFactor]);\n\n  const handleMouseEvents = useMemo(\n    () => ({\n      onMouseEnter: () => hoverEffect && setIsHovered(true),\n      onMouseLeave: () => {\n        if (hoverEffect) setIsHovered(false);\n        if (clickEffect) setIsClicked(false);\n      },\n      onMouseDown: () => clickEffect && setIsClicked(true),\n      onMouseUp: () => clickEffect && setIsClicked(false),\n      onTouchStart: () => clickEffect && setIsClicked(true),\n      onTouchEnd: () => clickEffect && setIsClicked(false),\n    }),\n    [hoverEffect, clickEffect],\n  );\n\n  const displayPath =\n    smooth && paths.previous\n      ? interpolatePaths(\n          paths.previous,\n          paths.current,\n          animationProgress.current,\n        )\n      : paths.current;\n\n  return (\n    <div\n      ref={blobRef}\n      className={cn(\n        \"relative flex items-center justify-center transition-all duration-500\",\n        SIZE_CLASSES[size],\n        glow && GLOW_INTENSITY_CLASSES[glowIntensity],\n        glow && currentTheme.glow,\n        pulse && \"animate-pulse\",\n        className,\n      )}\n      style={{\n        opacity: opacity / 100,\n        willChange: \"transform, opacity\",\n      }}\n      {...handleMouseEvents}\n      {...props}\n    >\n      <svg\n        viewBox=\"0 0 100 100\"\n        className=\"absolute inset-0 w-full h-full\"\n        style={{\n          transform: `rotate(${rotation}deg)`,\n          transition: \"transform 8s ease-in-out\",\n          filter: glow ? currentTheme.filter : \"none\",\n          willChange: \"transform, filter\",\n        }}\n        aria-hidden=\"true\"\n      >\n        {effect3D && (\n          <path\n            d={displayPath}\n            className=\"transition-all duration-300\"\n            fill=\"rgba(0,0,0,0.15)\"\n            transform=\"translate(3,3) scale(0.99)\"\n          />\n        )}\n        <path\n          d={displayPath}\n          className=\"transition-all duration-300\"\n          fill={`url(#${gradientId})`}\n        />\n        {effect3D && (\n          <path\n            d={displayPath}\n            className=\"transition-all duration-300\"\n            fill=\"rgba(255,255,255,0.1)\"\n            transform=\"translate(-1.5,-1.5) scale(0.98)\"\n          />\n        )}\n        <defs>\n          <linearGradient id={gradientId} x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">\n            <stop offset=\"0%\" stopColor={currentTheme.from} />\n            {currentTheme.via && (\n              <stop offset=\"50%\" stopColor={currentTheme.via} />\n            )}\n            <stop offset=\"100%\" stopColor={currentTheme.to} />\n          </linearGradient>\n        </defs>\n      </svg>\n      {children && (\n        <div className=\"relative z-10 flex items-center justify-center text-white transition-all duration-300\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/ui/morphing-blob.tsx"
    },
    {
      "path": "registry\\ui\\morphing-blob.tsx",
      "content": "\"use client\";\nimport React, {\n  useRef,\n  useEffect,\n  useState,\n  useMemo,\n  useCallback,\n  useId,\n} from \"react\";\nimport { cn } from \"../../lib/utils\";\n\nexport interface MorphingBlobProps\n  extends React.HTMLAttributes<HTMLDivElement> {\n  theme?:\n    | \"primary\"\n    | \"secondary\"\n    | \"accent\"\n    | \"success\"\n    | \"warning\"\n    | \"danger\"\n    | \"custom\";\n  customColors?: {\n    from: string;\n    via?: string;\n    to: string;\n  };\n  size?: \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n  complexity?: 1 | 2 | 3 | 4 | 5;\n  speed?: 1 | 2 | 3 | 4 | 5;\n  hoverEffect?: boolean;\n  clickEffect?: boolean;\n  pulse?: boolean;\n  glow?: boolean;\n  glowIntensity?: 1 | 2 | 3 | 4 | 5;\n  opacity?: number;\n  smooth?: boolean;\n  effect3D?: boolean;\n  children?: React.ReactNode;\n}\ntype ComplexityFactor = {\n  points: number;\n  variance: number;\n  tension: number;\n};\nconst COMPLEXITY_FACTORS = {\n  1: { points: 6, variance: 0.15, tension: 0.25 },\n  2: { points: 8, variance: 0.25, tension: 0.35 },\n  3: { points: 10, variance: 0.3, tension: 0.4 },\n  4: { points: 12, variance: 0.35, tension: 0.45 },\n  5: { points: 16, variance: 0.4, tension: 0.5 },\n};\n\nconst SPEED_FACTORS = {\n  1: 15000, // Slower\n  2: 12000,\n  3: 9000,\n  4: 6000,\n  5: 3000, // Faster\n};\n\nconst SIZE_CLASSES = {\n  sm: \"w-32 h-32 md:w-40 md:h-40\",\n  md: \"w-48 h-48 md:w-64 md:h-64\",\n  lg: \"w-64 h-64 md:w-80 md:h-80\",\n  xl: \"w-80 h-80 md:w-[32rem] md:h-[32rem]\",\n  full: \"w-full h-full\",\n};\n\nconst GLOW_INTENSITY_CLASSES = {\n  1: \"shadow-sm\",\n  2: \"shadow-md\",\n  3: \"shadow-lg\",\n  4: \"shadow-xl\",\n  5: \"shadow-2xl\",\n};\n\nfunction hexToRgba(hex: string, alpha: number): string {\n  const r = parseInt(hex.slice(1, 3), 16);\n  const g = parseInt(hex.slice(3, 5), 16);\n  const b = parseInt(hex.slice(5, 7), 16);\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\nfunction easeInOutCubic(x: number): number {\n  return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;\n}\n\nfunction isValidNumber(num: number): boolean {\n  return typeof num === \"number\" && !isNaN(num) && isFinite(num);\n}\n\nexport function MorphingBlob({\n  theme = \"primary\",\n  customColors,\n  size = \"md\",\n  complexity = 3,\n  speed = 3,\n  hoverEffect = true,\n  clickEffect = true,\n  pulse = false,\n  glow = true,\n  glowIntensity = 3,\n  opacity = 100,\n  smooth = true,\n  effect3D = false,\n  className,\n  children,\n  ...props\n}: MorphingBlobProps) {\n  const blobRef = useRef<HTMLDivElement>(null);\n  const [isHovered, setIsHovered] = useState(false);\n  const [isClicked, setIsClicked] = useState(false);\n  const [paths, setPaths] = useState({ current: \"\", previous: \"\" });\n  const [rotation, setRotation] = useState(0);\n  const animationRef = useRef<number | null>(null);\n  const previousTimeRef = useRef<number | null>(null);\n  const animationProgress = useRef(0);\n  const instanceId = useId();\n  const gradientId = `blob-gradient-${theme}-${instanceId.replace(/:/g, \"\")}`;\n\n  // Memoize theme colors to prevent recalculation\n  const themeColors = useMemo(\n    () => ({\n      primary: {\n        from: \"#4F46E5\",\n        via: \"#6366F1\",\n        to: \"#818CF8\",\n        glow: \"shadow-indigo-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(99, 102, 241, 0.4))\",\n      },\n      secondary: {\n        from: \"#9333EA\",\n        via: \"#A855F7\",\n        to: \"#C084FC\",\n        glow: \"shadow-purple-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(168, 85, 247, 0.4))\",\n      },\n      accent: {\n        from: \"#0D9488\",\n        via: \"#14B8A6\",\n        to: \"#2DD4BF\",\n        glow: \"shadow-teal-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(20, 184, 166, 0.4))\",\n      },\n      success: {\n        from: \"#16A34A\",\n        via: \"#22C55E\",\n        to: \"#4ADE80\",\n        glow: \"shadow-green-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(34, 197, 94, 0.4))\",\n      },\n      warning: {\n        from: \"#D97706\",\n        via: \"#F59E0B\",\n        to: \"#FBBF24\",\n        glow: \"shadow-amber-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(245, 158, 11, 0.4))\",\n      },\n      danger: {\n        from: \"#DC2626\",\n        via: \"#EF4444\",\n        to: \"#F87171\",\n        glow: \"shadow-red-500/40\",\n        filter: \"drop-shadow(0 0 10px rgba(239, 68, 68, 0.4))\",\n      },\n      custom: {\n        from: customColors?.from || \"#000000\",\n        via: customColors?.via || \"#000000\",\n        to: customColors?.to || \"#02001c\",\n        glow: \"shadow-blue-500/40\",\n        filter: `drop-shadow(0 0 10px ${customColors?.from ? hexToRgba(customColors.from, 0.4) : \"rgba(59, 130, 246, 0.4)\"})`,\n      },\n    }),\n    [customColors],\n  );\n\n  const currentTheme = themeColors[theme];\n  const complexityFactor = COMPLEXITY_FACTORS[complexity];\n  const speedValue = SPEED_FACTORS[speed];\n  const generateBlobPath = useCallback(\n    (factor: ComplexityFactor, hover = false, click = false) => {\n      const { points, variance, tension } = factor;\n      const centerX = 50;\n      const centerY = 50;\n      const baseRadius = hover ? 42 : click ? 38 : 40;\n      const angleStep = (Math.PI * 2) / points;\n      const blobPoints = [];\n      for (let i = 0; i < points; i++) {\n        const angle = i * angleStep;\n        const waveVariation =\n          Math.sin(i * 3) * 0.08 +\n          Math.sin(i * 5) * 0.05 +\n          Math.sin(i * 7) * 0.03;\n        const randomVariance =\n          1 - variance + Math.random() * variance * 2 + waveVariation;\n        const radius = Math.max(baseRadius * randomVariance, baseRadius * 0.6);\n\n        blobPoints.push({\n          x: centerX + Math.cos(angle) * radius,\n          y: centerY + Math.sin(angle) * radius,\n        });\n      }\n      let path = `M${blobPoints[0].x},${blobPoints[0].y}`;\n      for (let i = 0; i < points; i++) {\n        const current = blobPoints[i];\n        const next = blobPoints[(i + 1) % points];\n        const prev = blobPoints[(i - 1 + points) % points];\n        const nextNext = blobPoints[(i + 2) % points];\n\n        const cp1x = current.x + (next.x - prev.x) * tension;\n        const cp1y = current.y + (next.y - prev.y) * tension;\n        const cp2x = next.x - (nextNext.x - current.x) * tension;\n        const cp2y = next.y - (nextNext.y - current.y) * tension;\n\n        const validCp1x = isValidNumber(cp1x) ? cp1x : current.x;\n        const validCp1y = isValidNumber(cp1y) ? cp1y : current.y;\n        const validCp2x = isValidNumber(cp2x) ? cp2x : next.x;\n        const validCp2y = isValidNumber(cp2y) ? cp2y : next.y;\n\n        path += ` C${validCp1x},${validCp1y} ${validCp2x},${validCp2y} ${next.x},${next.y}`;\n      }\n\n      return path + \" Z\";\n    },\n    [],\n  );\n  const interpolatePaths = useCallback(\n    (path1: string, path2: string, progress: number) => {\n      if (!path1 || !path2) return path2 || path1 || \"\";\n      const extractPoints = (path: string) => {\n        const regex = /([MC]) ?([^MC]+)/g;\n        const points = [];\n        let match;\n\n        while ((match = regex.exec(path)) !== null) {\n          const [, command, coordStr] = match;\n          const coords = coordStr\n            .trim()\n            .split(/[ ,]/)\n            .filter(Boolean)\n            .map(parseFloat);\n          if (command === \"M\" && coords.length >= 2) {\n            points.push([coords[0], coords[1]]);\n          } else if (command === \"C\" && coords.length >= 6) {\n            points.push([coords[4], coords[5]]);\n          }\n        }\n\n        return points;\n      };\n\n      const points1 = extractPoints(path1);\n      const points2 = extractPoints(path2);\n\n      if (points1.length !== points2.length || points1.length === 0) {\n        return path2;\n      }\n      const easeProgress = easeInOutCubic(progress);\n      const interpolatedPoints = points1.map((point, i) => {\n        if (i < points2.length) {\n          const x = point[0] + (points2[i][0] - point[0]) * easeProgress;\n          const y = point[1] + (points2[i][1] - point[1]) * easeProgress;\n          return [\n            isValidNumber(x) ? x : point[0],\n            isValidNumber(y) ? y : point[1],\n          ];\n        }\n        return point;\n      });\n      let newPath = `M${interpolatedPoints[0][0]},${interpolatedPoints[0][1]}`;\n      const tension = 0.4;\n\n      for (let i = 0; i < interpolatedPoints.length; i++) {\n        const curr = interpolatedPoints[i];\n        const next = interpolatedPoints[(i + 1) % interpolatedPoints.length];\n        const prev =\n          interpolatedPoints[\n            (i - 1 + interpolatedPoints.length) % interpolatedPoints.length\n          ];\n        const nextNext =\n          interpolatedPoints[(i + 2) % interpolatedPoints.length];\n        const cpx1 = curr[0] + (next[0] - prev[0]) * tension;\n        const cpy1 = curr[1] + (next[1] - prev[1]) * tension;\n        const cpx2 = next[0] - (nextNext[0] - curr[0]) * tension;\n        const cpy2 = next[1] - (nextNext[1] - curr[1]) * tension;\n        const validCpx1 = isValidNumber(cpx1) ? cpx1 : curr[0];\n        const validCpy1 = isValidNumber(cpy1) ? cpy1 : curr[1];\n        const validCpx2 = isValidNumber(cpx2) ? cpx2 : next[0];\n        const validCpy2 = isValidNumber(cpy2) ? cpy2 : next[1];\n        newPath += ` C${validCpx1},${validCpy1} ${validCpx2},${validCpy2} ${next[0]},${next[1]}`;\n      }\n\n      return newPath + \" Z\";\n    },\n    [],\n  );\n\n  const animate = useCallback(\n    (time: number) => {\n      if (previousTimeRef.current === null) {\n        previousTimeRef.current = time;\n        animationRef.current = requestAnimationFrame(animate);\n        return;\n      }\n      const deltaTime = time - previousTimeRef.current;\n      const duration = speedValue;\n      animationProgress.current += deltaTime / duration;\n      if (animationProgress.current >= 1) {\n        animationProgress.current = 0;\n        setPaths((prev) => ({\n          previous: prev.current,\n          current: generateBlobPath(complexityFactor, isHovered, isClicked),\n        }));\n\n        setRotation((prev) => (prev + 15 + Math.random() * 30) % 360);\n      }\n\n      previousTimeRef.current = time;\n      animationRef.current = requestAnimationFrame(animate);\n    },\n    [speedValue, complexityFactor, isHovered, isClicked, generateBlobPath],\n  );\n\n  useEffect(() => {\n    if (!paths.current) {\n      const initialPath = generateBlobPath(\n        complexityFactor,\n        isHovered,\n        isClicked,\n      );\n      setPaths({ current: initialPath, previous: initialPath });\n    }\n\n    if (animationRef.current) {\n      cancelAnimationFrame(animationRef.current);\n      animationRef.current = null;\n    }\n    if (smooth) {\n      animationRef.current = requestAnimationFrame(animate);\n      return () => {\n        if (animationRef.current !== null) {\n          cancelAnimationFrame(animationRef.current);\n          animationRef.current = null;\n        }\n      };\n    } else {\n      const interval = setInterval(() => {\n        setPaths((prev) => ({\n          previous: prev.current,\n          current: generateBlobPath(complexityFactor, isHovered, isClicked),\n        }));\n        setRotation((prev) => (prev + 15 + Math.random() * 30) % 360);\n      }, speedValue / 6);\n      return () => clearInterval(interval);\n    }\n  }, [\n    complexity,\n    speed,\n    isHovered,\n    isClicked,\n    smooth,\n    animate,\n    complexityFactor,\n    speedValue,\n    generateBlobPath,\n    paths,\n  ]);\n\n  useEffect(() => {\n    setPaths((prev) => ({\n      previous: prev.current,\n      current: generateBlobPath(complexityFactor, isHovered, isClicked),\n    }));\n    setRotation((prev) => (prev + 15 + Math.random() * 30) % 360);\n    animationProgress.current = 0;\n  }, [isHovered, isClicked, generateBlobPath, complexityFactor]);\n\n  const handleMouseEvents = useMemo(\n    () => ({\n      onMouseEnter: () => hoverEffect && setIsHovered(true),\n      onMouseLeave: () => {\n        if (hoverEffect) setIsHovered(false);\n        if (clickEffect) setIsClicked(false);\n      },\n      onMouseDown: () => clickEffect && setIsClicked(true),\n      onMouseUp: () => clickEffect && setIsClicked(false),\n      onTouchStart: () => clickEffect && setIsClicked(true),\n      onTouchEnd: () => clickEffect && setIsClicked(false),\n    }),\n    [hoverEffect, clickEffect],\n  );\n\n  const displayPath =\n    smooth && paths.previous\n      ? interpolatePaths(\n          paths.previous,\n          paths.current,\n          animationProgress.current,\n        )\n      : paths.current;\n\n  return (\n    <div\n      ref={blobRef}\n      className={cn(\n        \"relative flex items-center justify-center transition-all duration-500\",\n        SIZE_CLASSES[size],\n        glow && GLOW_INTENSITY_CLASSES[glowIntensity],\n        glow && currentTheme.glow,\n        pulse && \"animate-pulse\",\n        className,\n      )}\n      style={{\n        opacity: opacity / 100,\n        willChange: \"transform, opacity\",\n      }}\n      {...handleMouseEvents}\n      {...props}\n    >\n      <svg\n        viewBox=\"0 0 100 100\"\n        className=\"absolute inset-0 w-full h-full\"\n        style={{\n          transform: `rotate(${rotation}deg)`,\n          transition: \"transform 8s ease-in-out\",\n          filter: glow ? currentTheme.filter : \"none\",\n          willChange: \"transform, filter\",\n        }}\n        aria-hidden=\"true\"\n      >\n        {effect3D && (\n          <path\n            d={displayPath}\n            className=\"transition-all duration-300\"\n            fill=\"rgba(0,0,0,0.15)\"\n            transform=\"translate(3,3) scale(0.99)\"\n          />\n        )}\n        <path\n          d={displayPath}\n          className=\"transition-all duration-300\"\n          fill={`url(#${gradientId})`}\n        />\n        {effect3D && (\n          <path\n            d={displayPath}\n            className=\"transition-all duration-300\"\n            fill=\"rgba(255,255,255,0.1)\"\n            transform=\"translate(-1.5,-1.5) scale(0.98)\"\n          />\n        )}\n        <defs>\n          <linearGradient id={gradientId} x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">\n            <stop offset=\"0%\" stopColor={currentTheme.from} />\n            {currentTheme.via && (\n              <stop offset=\"50%\" stopColor={currentTheme.via} />\n            )}\n            <stop offset=\"100%\" stopColor={currentTheme.to} />\n          </linearGradient>\n        </defs>\n      </svg>\n      {children && (\n        <div className=\"relative z-10 flex items-center justify-center text-white transition-all duration-300\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}