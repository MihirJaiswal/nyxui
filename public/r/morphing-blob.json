{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "morphing-blob",
  "type": "registry:ui",
  "title": "Morphing Blob",
  "description": "A morphing blob that that provide several effects.",
  "dependencies": [
    "three",
    "@react-three/fiber",
    "@react-three/drei",
    "@react-three/postprocessing",
    "@react-three/fiber",
    "@react-three/postprocessing",
    "@react-three/drei",
    "three"
  ],
  "files": [
    {
      "path": "registry/ui/morphing-blob.tsx",
      "content": "'use client'\r\nimport React, { useMemo, useRef, Suspense, useState, useEffect } from \"react\"\r\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\"\r\nimport { EffectComposer, Bloom, ChromaticAberration } from \"@react-three/postprocessing\"\r\nimport { Environment } from \"@react-three/drei\"\r\nimport * as THREE from \"three\"\r\n\r\n/* --------------------------  SHADERS  ---------------------------- */\r\n\r\nconst vertexShader = /* glsl */ `\r\n  uniform float uTime;\r\n  uniform float uComplexity;\r\n  uniform float uSpeed;\r\n  uniform vec2  uPointer;\r\n  uniform float uInfluence;\r\n\r\n  varying vec3 vNormal;\r\n  varying vec3 vPosition;\r\n  varying vec3 vWorldPosition;\r\n\r\n  /* Simplex noise helpers ........................................ */\r\n  vec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\r\n  vec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\r\n  vec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}\r\n  vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}\r\n\r\n  float snoise(vec3 v){\r\n    const vec2  C = vec2(1./6., 1./3.);\r\n    const vec4  D = vec4(0.,.5,1.,2.);\r\n\r\n    vec3 i = floor(v + dot(v, C.yyy));\r\n    vec3 x0 = v - i + dot(i, C.xxx);\r\n    vec3 g = step(x0.yzx, x0.xyz);\r\n    vec3 l = 1. - g;\r\n    vec3 i1 = min(g.xyz, l.zxy);\r\n    vec3 i2 = max(g.xyz, l.zxy);\r\n    vec3 x1 = x0 - i1 + C.xxx;\r\n    vec3 x2 = x0 - i2 + C.yyy;\r\n    vec3 x3 = x0 - D.yyy;\r\n\r\n    i = mod289(i);\r\n    vec4 p = permute( permute( permute(\r\n              i.z + vec4(0., i1.z, i2.z, 1.))\r\n            + i.y + vec4(0., i1.y, i2.y, 1.))\r\n            + i.x + vec4(0., i1.x, i2.x, 1.));\r\n\r\n    float n_ = 1./7.;\r\n    vec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n    vec4 j = p - 49. * floor(p * ns.z * ns.z);\r\n    vec4 x_ = floor(j * ns.z);\r\n    vec4 y_ = floor(j - 7. * x_);\r\n\r\n    vec4 x = x_ * ns.x + ns.yyyy;\r\n    vec4 y = y_ * ns.x + ns.yyyy;\r\n    vec4 h = 1. - abs(x) - abs(y);\r\n\r\n    vec4 b0 = vec4(x.xy, y.xy);\r\n    vec4 b1 = vec4(x.zw, y.zw);\r\n\r\n    vec4 s0 = floor(b0)*2.+1.;\r\n    vec4 s1 = floor(b1)*2.+1.;\r\n    vec4 sh = -step(h, vec4(0.));\r\n\r\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\r\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\r\n\r\n    vec3 p0 = vec3(a0.xy,h.x);\r\n    vec3 p1 = vec3(a0.zw,h.y);\r\n    vec3 p2 = vec3(a1.xy,h.z);\r\n    vec3 p3 = vec3(a1.zw,h.w);\r\n\r\n    vec4 norm = taylorInvSqrt(vec4(\r\n      dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\r\n    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3*=norm.w;\r\n\r\n    vec4 m = max(0.6 - vec4(\r\n      dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\r\n    m = m*m;\r\n    return 42. * dot(m*m, vec4(\r\n      dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\r\n  }\r\n\r\n  void main(){\r\n    vNormal = normal;\r\n    vPosition = position;\r\n    vec3 pos = position;\r\n\r\n    float n1 = snoise(pos*2.+uTime*uSpeed);\r\n    float n2 = snoise(pos*4.+uTime*uSpeed*1.5);\r\n    float n3 = snoise(pos*8.+uTime*uSpeed*0.8);\r\n    float n4 = snoise(pos*16.+uTime*uSpeed*0.3);\r\n    float disp = (n1*.4 + n2*.3 + n3*.2 + n4*.1)*uComplexity;\r\n\r\n    vec3 world = (modelMatrix*vec4(pos,1.)).xyz;\r\n    float d = distance(world.xy, vec2(uPointer.x*8., uPointer.y*8.));\r\n    float influence = exp(-d*0.5)*uInfluence;\r\n\r\n    pos += normal * (disp + influence);\r\n    vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);\r\n  }\r\n`\r\n\r\nconst fragmentShader = /* glsl */ `\r\n  uniform float uTime;\r\n  uniform vec3  uA;\r\n  uniform vec3  uB;\r\n  uniform vec3  uC;\r\n\r\n  varying vec3 vNormal;\r\n  varying vec3 vPosition;\r\n  varying vec3 vWorldPosition;\r\n\r\n  void main(){\r\n    float dist = length(vPosition);\r\n    float alpha = 1.0 - smoothstep(1.8, 2.2, dist);\r\n    \r\n    if(alpha < 0.01) discard;\r\n    \r\n    float grad = vNormal.y*0.5 + 0.5;\r\n    \r\n    float mix1 = sin(uTime*0.6+vPosition.x*3.+vPosition.z*2.)*0.4+0.6;\r\n    float mix2 = cos(uTime*0.4+vPosition.y*2.5+vPosition.z*3.)*0.4+0.6;\r\n    float mix3 = sin(uTime*0.3+vPosition.x*1.5+vPosition.y*2.)*0.3+0.7;\r\n    \r\n    grad = smoothstep(0.1, 0.9, grad);\r\n    mix1 = smoothstep(0.2, 1.0, mix1);\r\n    mix2 = smoothstep(0.2, 1.0, mix2);\r\n    mix3 = smoothstep(0.4, 1.0, mix3);\r\n    \r\n    vec3 col = mix(uA, uB, grad);\r\n    col = mix(col, uC, mix1 * mix2 * 0.6);\r\n    \r\n    vec3 accent = mix(uB, uC, mix3);\r\n    col = mix(col, accent, 0.35);\r\n    \r\n    float rim = 1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 1.5);\r\n    \r\n    col = mix(col, col * col, 0.6);\r\n    col = pow(col, vec3(0.7));\r\n    \r\n    vec3 rimColor = mix(uB, uC, 0.5);\r\n    col += rimColor * rim * 0.6;\r\n    \r\n    col *= 1.3;\r\n    col = min(col, vec3(1.4));\r\n    \r\n    gl_FragColor = vec4(col, alpha * 0.95);\r\n  }\r\n`\r\n\r\n// Precompiled shader material\r\nconst shaderMaterial = new THREE.ShaderMaterial({\r\n  vertexShader,\r\n  fragmentShader,\r\n  transparent: true,\r\n  alphaTest: 0.01,\r\n  side: THREE.DoubleSide,\r\n})\r\n\r\n/* ----------------------  BLOB   MESH  ----------------------------- */\r\n\r\nfunction Blob({\r\n  theme,\r\n  complexity,\r\n  speed,\r\n}: {\r\n  theme: \"primary\" | \"aurora\" | \"cosmic\" | \"liquid\" | \"danger\"\r\n  complexity: number\r\n  speed: number\r\n}) {\r\n  const { pointer, clock } = useThree()\r\n  const mesh = useRef<THREE.Mesh>(null!)\r\n  const themes = {\r\n    primary: { a: \"#0A0F8A\", b: \"#1E40FF\", c: \"#00D4FF\" },\r\n    aurora: { a: \"#4A00FF\", b: \"#FF006B\", c: \"#00FFFF\" },\r\n    cosmic: { a: \"#660A8A\", b: \"#C81EFF\", c: \"#B700FF\" },\r\n    liquid: { a: \"#805AFC\", b: \"#04E9AD\", c: \"#FC8EED\" },\r\n    danger: { a: \"#FF0000\", b: \"#FF4000\", c: \"#FFAA00\" },\r\n  } as const\r\n\r\n  const { a, b, c } = themes[theme] ?? themes.aurora\r\n  const geometry = useMemo(() => new THREE.IcosahedronGeometry(2, 6), []) // Keep original quality\r\n\r\n  // Stable uniforms reference\r\n  const uniforms = useMemo(\r\n    () => ({\r\n      uTime: { value: 0 },\r\n      uComplexity: { value: complexity * 0.15 },\r\n      uSpeed: { value: speed * 0.25 },\r\n      uPointer: { value: new THREE.Vector2(0, 0) },\r\n      uInfluence: { value: 0.6 },\r\n      uA: { value: new THREE.Color(a) },\r\n      uB: { value: new THREE.Color(b) },\r\n      uC: { value: new THREE.Color(c) },\r\n    }),\r\n    [a, b, c, complexity, speed],\r\n  )\r\n  const material = useMemo(() => {\r\n    const mat = shaderMaterial.clone()\r\n    mat.uniforms = uniforms\r\n    return mat\r\n  }, [uniforms])\r\n\r\n  useFrame(() => {\r\n    uniforms.uTime.value = clock.elapsedTime\r\n    uniforms.uPointer.value.copy(pointer)\r\n  })\r\n\r\n  return (\r\n    <mesh ref={mesh} geometry={geometry} material={material} />\r\n  )\r\n}\r\n\r\n/* ----------------------  PARTICLES  ------------------------------- */\r\n\r\nfunction Particles({ count = 150, color = \"#00FFFF\" }) { \r\n  const points = useRef<THREE.Points>(null!)\r\n  const { geometry, material } = useMemo(() => {\r\n    const pos = new Float32Array(count * 3)\r\n    const scl = new Float32Array(count)\r\n    for (let i = 0; i < count; i++) {\r\n      const r = 4 + Math.random() * 3\r\n      const theta = Math.random() * Math.PI * 2\r\n      const phi = Math.acos(Math.random() * 2 - 1)\r\n      pos[i * 3] = r * Math.sin(phi) * Math.cos(theta)\r\n      pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta)\r\n      pos[i * 3 + 2] = r * Math.cos(phi)\r\n      scl[i] = Math.random() * 0.8 + 0.2\r\n    }\r\n\r\n    const geom = new THREE.BufferGeometry()\r\n    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3))\r\n    geom.setAttribute('scale', new THREE.BufferAttribute(scl, 1))\r\n\r\n    const mat = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        uTime: { value: 0 },\r\n        uSize: { value: 35 },\r\n        uColor: { value: new THREE.Color(color) },\r\n      },\r\n      vertexShader: /* glsl */ `\r\n        uniform float uTime;\r\n        uniform float uSize;\r\n        attribute float scale;\r\n        void main(){\r\n          vec3 pos = position;\r\n          pos.x += sin(uTime * 0.4 + pos.y * 0.3) * 0.3;\r\n          pos.y += cos(uTime * 0.3 + pos.x * 0.3) * 0.3;\r\n          pos.z += sin(uTime * 0.2 + pos.x * 0.2) * 0.2;\r\n          vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);\r\n          gl_Position = projectionMatrix * mvPos;\r\n          gl_PointSize = uSize * scale * (1.0 / -mvPos.z);\r\n        }\r\n      `,\r\n      fragmentShader: /* glsl */ `\r\n        uniform vec3 uColor;\r\n        void main(){\r\n          float d = distance(gl_PointCoord, vec2(0.5));\r\n          if(d > 0.5) discard;\r\n          float alpha = 1.0 - (d * 2.0);\r\n          alpha = pow(alpha, 2.0) * 0.9;\r\n          gl_FragColor = vec4(uColor, alpha);\r\n        }\r\n      `,\r\n      blending: THREE.AdditiveBlending,\r\n      depthWrite: false,\r\n      transparent: true,\r\n    })\r\n\r\n    return { geometry: geom, material: mat }\r\n  }, [count, color])\r\n\r\n  useFrame(({ clock }) => {\r\n    material.uniforms.uTime.value = clock.elapsedTime\r\n  })\r\n\r\n  return <points ref={points} geometry={geometry} material={material} />\r\n}\r\n\r\n/* ----------------------  EFFECTS  -------------------------------- */\r\n\r\nfunction PostProcessingEffects({ enabled = true }: { enabled?: boolean }) {\r\n  if (!enabled) return null\r\n\r\n  return (\r\n    <EffectComposer>\r\n      <Bloom \r\n        intensity={1.5} \r\n        luminanceThreshold={0.02}\r\n        luminanceSmoothing={0.8}\r\n      />\r\n      <ChromaticAberration offset={[0.002, 0.002]} />\r\n    </EffectComposer>\r\n  )\r\n}\r\n\r\n/* ----------------------  ERROR BOUNDARY  ------------------------- */\r\n\r\nclass EnvironmentErrorBoundary extends React.Component<\r\n  { children: React.ReactNode; fallback: React.ReactNode },\r\n  { hasError: boolean }\r\n> {\r\n  constructor(props: { children: React.ReactNode; fallback: React.ReactNode }) {\r\n    super(props)\r\n    this.state = { hasError: false }\r\n  }\r\n\r\n  static getDerivedStateFromError() {\r\n    return { hasError: true }\r\n  }\r\n\r\n  componentDidCatch() {\r\n    // Environment loading failed\r\n  }\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return this.props.fallback\r\n    }\r\n    return this.props.children\r\n  }\r\n}\r\n\r\n/* ----------------------  SCENE  ---------------------------------- */\r\n\r\nfunction Scene({\r\n  theme = \"aurora\",\r\n  complexity = 3,\r\n  speed = 3,\r\n  particleCount = 150,\r\n  enableEffects = true,\r\n}: {\r\n  theme?: \"primary\" | \"aurora\" | \"cosmic\" | \"liquid\" | \"danger\"\r\n  complexity?: number\r\n  speed?: number\r\n  particleCount?: number\r\n  enableEffects?: boolean\r\n}) {\r\n  const particleColors = {\r\n    primary: \"#00D4FF\",\r\n    aurora: \"#00FFD4\",\r\n    cosmic: \"#FF006B\",\r\n    liquid: \"#00FFAA\",\r\n    danger: \"#FFAA00\",\r\n  }\r\n\r\n  // Fallback lighting when Environment fails\r\n  const FallbackLighting = () => (\r\n    <>\r\n      <ambientLight intensity={0.4} color=\"#1a1a2e\" />\r\n      <pointLight position={[10, 10, 10]} intensity={1.8} color=\"#ffffff\" /> \r\n      <pointLight position={[-10, -10, -10]} intensity={1.2} color=\"#4444ff\" />\r\n      <pointLight position={[0, -10, 5]} intensity={0.8} color=\"#8844ff\" />\r\n    </>\r\n  )\r\n\r\n  return (\r\n    <>\r\n      <Blob theme={theme} complexity={complexity} speed={speed} />\r\n      <Particles count={particleCount} color={particleColors[theme]} />\r\n      <ambientLight intensity={0.3} />\r\n      <pointLight position={[10, 10, 10]} intensity={1.5} color=\"#ffffff\" /> \r\n      <pointLight position={[-10, -10, -10]} intensity={1.0} color=\"#4444ff\" />\r\n      <EnvironmentErrorBoundary fallback={<FallbackLighting />}>\r\n        <Suspense fallback={<FallbackLighting />}>\r\n          <Environment preset=\"night\" />\r\n        </Suspense>\r\n      </EnvironmentErrorBoundary>\r\n\r\n      <PostProcessingEffects enabled={enableEffects} />\r\n    </>\r\n  )\r\n}\r\n\r\n/* --------------------  EXPORTED  COMPONENT  ----------------------- */\r\n\r\nexport function MorphingBlob({\r\n  size = 400,\r\n  theme = \"aurora\",\r\n  complexity = 3,\r\n  speed = 3,\r\n  particleCount = 150,\r\n  enableEffects = true,\r\n  children,\r\n  className,\r\n  ...rest\r\n}: {\r\n  size?: number\r\n  theme?: \"primary\" | \"aurora\" | \"cosmic\" | \"liquid\" | \"danger\"\r\n  complexity?: number\r\n  speed?: number\r\n  particleCount?: number\r\n  enableEffects?: boolean\r\n  children?: React.ReactNode\r\n  className?: string\r\n} & React.HTMLAttributes<HTMLDivElement>) {\r\n  const [isClient, setIsClient] = useState(false)\r\n\r\n  useEffect(() => {\r\n    setIsClient(true)\r\n  }, [])\r\n  const FallbackComponent = () => (\r\n    <div \r\n      className={className} \r\n      style={{ \r\n        width: size, \r\n        height: size, \r\n        position: 'relative',\r\n        display: 'flex',\r\n        alignItems: 'center',\r\n        justifyContent: 'center',\r\n        background: `radial-gradient(circle at 30% 30%, ${\r\n          theme === 'aurora' ? 'rgba(74, 0, 255, 0.2)' :\r\n          theme === 'cosmic' ? 'rgba(183, 102, 234, 0.2)' :\r\n          theme === 'liquid' ? 'rgba(128, 90, 252, 0.2)' :\r\n          theme === 'danger' ? 'rgba(255, 0, 0, 0.2)' :\r\n          'rgba(10, 15, 138, 0.2)'\r\n        }, transparent 70%)`,\r\n        borderRadius: '50%',\r\n        overflow: 'hidden'\r\n      }} \r\n      {...rest}\r\n    >\r\n      {children}\r\n    </div>\r\n  )\r\n\r\n  if (!isClient) {\r\n    return <FallbackComponent />\r\n  }\r\n\r\n  return (\r\n    <div \r\n      className={className} \r\n      style={{ \r\n        width: size, \r\n        height: size, \r\n        position: 'relative',\r\n        display: 'flex',\r\n        alignItems: 'center',\r\n        justifyContent: 'center'\r\n      }} \r\n      {...rest}\r\n    >\r\n      <div style={{\r\n        position: 'absolute',\r\n        top: 0,\r\n        left: 0,\r\n        width: '100%',\r\n        height: '100%',\r\n        zIndex: 1,\r\n      }}>\r\n        <Canvas \r\n          camera={{ position: [0, 0, 8], fov: 45 }} \r\n          gl={{ \r\n            antialias: true, // Re-enabled for quality\r\n            alpha: true,\r\n            powerPreference: \"high-performance\",\r\n            premultipliedAlpha: false,\r\n            preserveDrawingBuffer: false,\r\n            failIfMajorPerformanceCaveat: false,\r\n            stencil: false,\r\n            depth: true\r\n          }}\r\n          dpr={[1, 2]} // Responsive DPR for better quality\r\n          style={{ \r\n            background: 'transparent',\r\n            width: '100%',\r\n            height: '100%'\r\n          }}\r\n          onCreated={({ gl }) => {\r\n            gl.toneMapping = THREE.ACESFilmicToneMapping\r\n            gl.toneMappingExposure = 1.5 \r\n            gl.setClearColor(0x000000, 0)\r\n          }}\r\n        >\r\n          <Scene \r\n            theme={theme} \r\n            complexity={complexity} \r\n            speed={speed} \r\n            particleCount={particleCount}\r\n            enableEffects={enableEffects}\r\n          />\r\n        </Canvas>\r\n      </div>\r\n\r\n      {children && (\r\n        <div style={{ position: 'relative', zIndex: 2 }}>\r\n          {children}\r\n        </div>\r\n      )}\r\n    </div>\r\n  )\r\n}",
      "type": "registry:ui",
      "target": "components/ui/morphing-blob.tsx"
    }
  ]
}