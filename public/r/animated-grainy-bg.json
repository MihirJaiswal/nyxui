{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "animated-grainy-bg",
  "type": "registry:ui",
  "title": "Animated Grainy Background",
  "description": "A dynamic animated gradient background component that supports various gradient patterns and animations.",
  "dependencies": [
    "motion",
    "framer-motion",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/animated-grainy-bg.tsx",
      "content": "\"use client\"\nimport type React from \"react\"\nimport { useRef, useMemo } from \"react\"\nimport { motion, type Variants } from \"framer-motion\"\nimport { cn } from \"@/lib/utils\"\n\nexport interface GrainyAnimatedBgProps {\n  children?: React.ReactNode\n  className?: string\n  colors?: string[]\n  speed?: number\n  grainType?: \"film\" | \"digital\" | \"vintage\" | \"plasma\" | \"scratches\" | \"paper\"\n  grainIntensity?: number\n  grainSize?: number\n  animationType?: \"flow\" | \"mesh\" | \"waves\" | \"aurora\" | \"spiral\" | \"pulse\"\n  size?: \"sm\" | \"md\" | \"lg\" | \"full\" | number\n  position?: \"fixed\" | \"absolute\" | \"relative\"\n  zIndex?: number\n  animate?: boolean\n  darkMode?: boolean\n  as?: \"div\" | \"section\" | \"article\" | \"main\" | \"aside\" | \"header\" | \"footer\"\n  onClick?: () => void\n}\n\nconst getSizeStyles = (size: GrainyAnimatedBgProps[\"size\"]): React.CSSProperties => {\n  if (typeof size === \"number\") {\n    return { width: `${size}px`, height: `${size}px` }\n  }\n  const sizeMap = {\n    sm: { width: \"300px\", height: \"300px\" },\n    md: { width: \"500px\", height: \"500px\" },\n    lg: { width: \"800px\", height: \"800px\" },\n    full: { width: \"100%\", height: \"100%\" }\n  } as const\n\n  return sizeMap[size || \"full\"]\n}\n\nconst getGrainSVG = (\n  type: NonNullable<GrainyAnimatedBgProps[\"grainType\"]>,\n  intensity: number,\n  size: number,\n  darkMode: boolean,\n): string => {\n  const baseFreq = size / 100\n  const opacity = (intensity / 100) * 0.8\n  const colorMatrix = darkMode ? \"0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0\" : \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\"\n  const grainConfigs = {\n    film: { freq: baseFreq * 0.9, octaves: 6, opacity },\n    digital: { freq: baseFreq * 1.3, octaves: 2, opacity: opacity * 1.1 },\n    vintage: { freq: baseFreq * 0.6, octaves: 4, opacity: opacity * 0.5 },\n    plasma: { freq: baseFreq * 0.25, octaves: 8, opacity: opacity * 0.7 },\n    scratches: { freq: baseFreq * 0.08, octaves: 1, opacity: opacity * 1.2 },\n    paper: { freq: baseFreq * 0.7, octaves: 5, opacity: opacity * 0.35 },\n  } as const\n  const config = grainConfigs[type]\n  const noiseType = type === \"scratches\" ? \"turbulence\" : \"fractalNoise\"\n  return `data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='${type}'%3E%3CfeTurbulence type='${noiseType}' baseFrequency='${config.freq}' numOctaves='${config.octaves}' result='noise'/%3E%3CfeColorMatrix in='noise' type='saturate' values='0'/%3E%3CfeColorMatrix type='matrix' values='${colorMatrix} ${config.opacity}'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23${type})'/%3E%3C/svg%3E`\n}\n\n// Enhanced gradient patterns that use ALL colors from the array\nconst getGradientPattern = (\n  pattern: NonNullable<GrainyAnimatedBgProps[\"animationType\"]>,\n  colors: string[],\n  darkMode = false,\n): string => {\n  const defaultColor = darkMode ? \"#2d1b69\" : \"#ff6b6b\"\n  const finalColors = colors.length > 0 ? colors : [defaultColor]\n  const baseOpacity = darkMode ? \"70\" : \"60\"\n  const lightOpacity = darkMode ? \"50\" : \"40\"\n  const heavyOpacity = darkMode ? \"85\" : \"75\"\n  const ultraLightOpacity = darkMode ? \"30\" : \"25\"\n  const getColor = (index: number) => finalColors[index % finalColors.length]\n\n  const gradientPatterns = {\n    flow: (): string => {\n      const gradients: string[] = []\n      finalColors.forEach((color, i) => {\n        const angle = (360 / finalColors.length) * i\n        const x = 50 + Math.cos(angle * Math.PI / 180) * 30\n        const y = 50 + Math.sin(angle * Math.PI / 180) * 30\n        gradients.push(`radial-gradient(circle at ${x}% ${y}%, ${color}${baseOpacity} 0%, ${color}20 40%, transparent 70%)`)\n      })\n      const colorStops = finalColors.map((color, i) =>\n        `${color}${lightOpacity} ${(i / Math.max(finalColors.length - 1, 1)) * 100}%`\n      ).join(', ')\n      gradients.push(`linear-gradient(135deg, ${colorStops})`)\n      return gradients.join(', ')\n    },\n\n    mesh: (): string => {\n      const gradients: string[] = []\n      const numNodes = finalColors.length\n      const meshPoints: { x: number; y: number; color: string; size: number }[] = []\n      // Generate mesh nodes with strategic positioning\n      finalColors.forEach((color, i) => {\n        const angle = i * 137.508\n        const radius = Math.sqrt(i) * 12\n        const x = 50 + Math.cos(angle * Math.PI / 180) * radius\n        const y = 50 + Math.sin(angle * Math.PI / 180) * radius\n        const clampedX = Math.max(10, Math.min(90, x))\n        const clampedY = Math.max(10, Math.min(90, y))\n\n        meshPoints.push({\n          x: clampedX,\n          y: clampedY,\n          color,\n          size: 120 + (i % 3) * 40\n        })\n      })\n\n      meshPoints.forEach((point, i) => {\n        const { x, y, color, size } = point\n        gradients.push(`radial-gradient(circle at ${x}% ${y}%, ${color}${heavyOpacity} 0%, ${color}${baseOpacity} 20%, ${color}${lightOpacity} 40%, ${color}${ultraLightOpacity} 60%, transparent 80%)`)\n        gradients.push(`radial-gradient(circle at ${x}% ${y}%, transparent 40%, ${color}${ultraLightOpacity} 45%, ${color}20 60%, transparent 85%)`)\n      })\n\n      meshPoints.forEach((point1, i) => {\n        meshPoints.forEach((point2, j) => {\n          if (i < j) {\n            const distance = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2))\n            if (distance < 40) {\n              const midX = (point1.x + point2.x) / 2\n              const midY = (point1.y + point2.y) / 2\n              const angle = Math.atan2(point2.y - point1.y, point2.x - point1.x) * 180 / Math.PI\n              gradients.push(`linear-gradient(${angle}deg, ${point1.color}${ultraLightOpacity} 0%, ${point2.color}${ultraLightOpacity} 50%, transparent 100%)`)\n              gradients.push(`radial-gradient(ellipse 150% 50% at ${midX}% ${midY}%, ${point1.color}${ultraLightOpacity} 0%, transparent 70%)`)\n            }\n          }\n        })\n      })\n\n      finalColors.forEach((color, i) => {\n        const x = 20 + (i * 60 / finalColors.length)\n        const y = 80 - (i * 60 / finalColors.length)\n        gradients.push(`radial-gradient(ellipse 300% 100% at ${x}% ${y}%, transparent 0%, ${color}${ultraLightOpacity} 30%, transparent 70%)`)\n      })\n\n      gradients.push(`repeating-linear-gradient(0deg, transparent 0%, ${finalColors[0]}10 1px, transparent 2px, transparent 20px)`)\n      gradients.push(`repeating-linear-gradient(90deg, transparent 0%, ${finalColors[1] || finalColors[0]}10 1px, transparent 2px, transparent 20px)`)\n      return gradients.join(', ')\n    },\n\n    waves: (): string => {\n      const gradients: string[] = []\n\n      finalColors.forEach((color, i) => {\n        const waveOffset = (i * 720 / finalColors.length) % 360\n        const x = 50 + Math.sin(waveOffset * Math.PI / 180) * 40\n        const y = (i / Math.max(finalColors.length - 1, 1)) * 100\n        gradients.push(`radial-gradient(ellipse 300% 80% at ${x}% ${y}%, ${color}${heavyOpacity} 0%, ${color}40 30%, transparent 60%)`)\n      })\n\n      finalColors.forEach((color, i) => {\n        const waveOffset = (i * 540 / finalColors.length) + 90\n        const y = 50 + Math.cos(waveOffset * Math.PI / 180) * 35\n        const x = (i / Math.max(finalColors.length - 1, 1)) * 100\n        gradients.push(`radial-gradient(ellipse 80% 200% at ${x}% ${y}%, ${color}${lightOpacity} 0%, transparent 50%)`)\n      })\n\n      return gradients.join(', ')\n    },\n\n    aurora: (): string => {\n      const gradients: string[] = []\n      finalColors.forEach((color, i) => {\n        const curtainAngle = 88 + (i * 8 / finalColors.length) - 4\n        const intensity = i % 2 === 0 ? heavyOpacity : baseOpacity\n        gradients.push(`linear-gradient(${curtainAngle}deg, \n      transparent 0%, \n      ${color}${ultraLightOpacity} 15%, \n      ${color}${lightOpacity} 25%, \n      ${color}${intensity} 40%, \n      ${color}${heavyOpacity} 50%, \n      ${color}${intensity} 60%, \n      ${color}${lightOpacity} 75%, \n      ${color}${ultraLightOpacity} 85%, \n      transparent 100%)`)\n        const secondaryAngle = curtainAngle + (i % 2 === 0 ? 3 : -3)\n        gradients.push(`linear-gradient(${secondaryAngle}deg, \n      transparent 0%, \n      ${color}${ultraLightOpacity} 20%, \n      ${color}${lightOpacity} 35%, \n      ${color}${baseOpacity} 50%, \n      ${color}${lightOpacity} 65%, \n      ${color}${ultraLightOpacity} 80%, \n      transparent 100%)`)\n      })\n\n      finalColors.forEach((color, i) => {\n        const waveY = 20 + (i * 60 / finalColors.length)\n        const waveIntensity = i % 3 === 0 ? baseOpacity : lightOpacity\n\n        gradients.push(`radial-gradient(ellipse 800% 40% at 50% ${waveY}%, \n      ${color}${waveIntensity} 0%, \n      ${color}${lightOpacity} 15%, \n      ${color}${ultraLightOpacity} 35%, \n      transparent 60%)`)\n        gradients.push(`radial-gradient(ellipse 600% 25% at 30% ${waveY + 5}%, \n      ${color}${ultraLightOpacity} 0%, \n      ${color}20 25%, \n      transparent 50%)`)\n\n        gradients.push(`radial-gradient(ellipse 600% 25% at 70% ${waveY - 3}%, \n      ${color}${ultraLightOpacity} 0%, \n      ${color}20 25%, \n      transparent 50%)`)\n      })\n\n      finalColors.forEach((color, i) => {\n        const coronaX = 25 + (i * 50 / finalColors.length)\n        const coronaY = 35 + Math.sin(i * 2.5) * 15\n        const nextColor = getColor(i + 1)\n        gradients.push(`radial-gradient(ellipse 80% 120% at ${coronaX}% ${coronaY}%, \n      ${color}${heavyOpacity} 0%, \n      ${color}${baseOpacity} 20%, \n      ${color}${lightOpacity} 40%, \n      ${color}${ultraLightOpacity} 60%, \n      transparent 80%)`)\n\n        gradients.push(`radial-gradient(ellipse 150% 200% at ${coronaX}% ${coronaY}%, \n      ${color}${lightOpacity} 0%, \n      ${color}${ultraLightOpacity} 30%, \n      transparent 60%)`)\n\n        gradients.push(`radial-gradient(ellipse 100% 80% at ${coronaX + 15}% ${coronaY + 10}%, \n      ${nextColor}${ultraLightOpacity} 0%, \n      ${nextColor}20 40%, \n      transparent 70%)`)\n      })\n\n      const scatterColor1 = getColor(0)\n      const scatterColor2 = getColor(Math.floor(finalColors.length / 2))\n      const scatterColor3 = getColor(finalColors.length - 1)\n\n      gradients.push(`radial-gradient(ellipse 200% 400% at 50% 0%, \n    ${scatterColor1}${ultraLightOpacity} 0%, \n    ${scatterColor1}20 30%, \n    transparent 70%)`)\n\n      gradients.push(`radial-gradient(ellipse 250% 300% at 20% 100%, \n    ${scatterColor2}${ultraLightOpacity} 0%, \n    ${scatterColor2}15 25%, \n    transparent 60%)`)\n      gradients.push(`radial-gradient(ellipse 200% 350% at 80% 100%, \n    ${scatterColor3}${ultraLightOpacity} 0%, \n    ${scatterColor3}15 25%, \n    transparent 60%)`)\n\n      finalColors.forEach((color, i) => {\n        for (let j = 0; j < 3; j++) {\n          const particleX = 20 + (i * 60 / finalColors.length) + (j * 20)\n          const particleY = 30 + Math.sin(i + j) * 20\n          const particleSize = 15 + (j * 5)\n\n          gradients.push(`radial-gradient(circle at ${particleX}% ${particleY}%, \n        ${color}${ultraLightOpacity} 0%, \n        ${color}15 ${particleSize}%, \n        transparent ${particleSize + 10}%)`)\n        }\n      })\n      const horizonColor = getColor(1)\n      gradients.push(`linear-gradient(0deg, \n    ${horizonColor}${ultraLightOpacity} 0%, \n    ${horizonColor}20 5%, \n    transparent 15%)`)\n      gradients.push(`linear-gradient(180deg, \n    ${scatterColor1}${ultraLightOpacity} 0%, \n    ${scatterColor1}15 10%, \n    transparent 25%)`)\n      return gradients.join(', ')\n    },\n\n    spiral: (): string => {\n      const gradients: string[] = []\n      // Create spiral pattern using all colors\n      finalColors.forEach((color, i) => {\n        const spiralAngle = (i * 360 / finalColors.length) + (i * 45)\n        const radius = 20 + (i * 15 / finalColors.length)\n        const x = 50 + Math.cos(spiralAngle * Math.PI / 180) * radius\n        const y = 50 + Math.sin(spiralAngle * Math.PI / 180) * radius\n        gradients.push(`radial-gradient(circle at ${x}% ${y}%, ${color}${baseOpacity} 0%, ${color}30 25%, transparent 50%)`)\n      })\n\n      // Add counter-spiral\n      finalColors.forEach((color, i) => {\n        const spiralAngle = -(i * 360 / finalColors.length) + (i * 60)\n        const radius = 15 + (i * 10 / finalColors.length)\n        const x = 50 + Math.cos(spiralAngle * Math.PI / 180) * radius\n        const y = 50 + Math.sin(spiralAngle * Math.PI / 180) * radius\n        gradients.push(`radial-gradient(ellipse 80% 120% at ${x}% ${y}%, ${color}${lightOpacity} 0%, transparent 40%)`)\n      })\n\n      return gradients.join(', ')\n    },\n\n    pulse: (): string => {\n      const gradients: string[] = []\n      finalColors.forEach((color, i) => {\n        const ringRadius = 20 + (i * 60 / finalColors.length)\n        gradients.push(`radial-gradient(circle at 50% 50%, transparent ${ringRadius - 10}%, ${color}${baseOpacity} ${ringRadius}%, ${color}30 ${ringRadius + 10}%, transparent ${ringRadius + 20}%)`)\n      })\n\n      finalColors.forEach((color, i) => {\n        const angle = (i * 360 / finalColors.length)\n        const x = 50 + Math.cos(angle * Math.PI / 180) * 20\n        const y = 50 + Math.sin(angle * Math.PI / 180) * 20\n        gradients.push(`radial-gradient(circle at ${x}% ${y}%, ${color}${lightOpacity} 0%, ${color}20 30%, transparent 60%)`)\n      })\n\n      return gradients.join(', ')\n    }\n  } as const\n\n  return gradientPatterns[pattern]()\n}\nconst defaultColors = {\n  light: [\"#ff6b6b\", \"#4ecdc4\", \"#45b7d1\"],\n  dark: [\"#2d1b69\", \"#11998e\", \"#0f3460\"],\n}\n\nexport const AnimatedGrainyBg: React.FC<GrainyAnimatedBgProps> = ({\n  children,\n  className,\n  colors,\n  speed = 1,\n  grainType = \"film\",\n  grainIntensity = 30,\n  grainSize = 80,\n  animationType = \"mesh\",\n  size = \"full\",\n  position = \"relative\",\n  zIndex = 0,\n  animate = true,\n  darkMode = false,\n  as = \"div\",\n  onClick,\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null)\n  const finalColors = colors || defaultColors[darkMode ? \"dark\" : \"light\"]\n  const gradient = useMemo(\n    () => getGradientPattern(animationType, finalColors, darkMode),\n    [animationType, finalColors, darkMode],\n  )\n  const grainSVG = useMemo(\n    () => getGrainSVG(grainType, grainIntensity, grainSize, darkMode),\n    [grainType, grainIntensity, grainSize, darkMode],\n  )\n\n  const variants: Variants = useMemo(() => {\n    const baseSpeed = 20 / speed\n    const animationConfigs = {\n      flow: {\n        backgroundPosition: [\"0% 0%\", \"100% 100%\", \"0% 100%\", \"100% 0%\", \"0% 0%\"],\n        backgroundSize: [\"400% 400%\", \"600% 600%\", \"400% 400%\"],\n        duration: baseSpeed,\n      },\n      mesh: {\n        backgroundPosition: [\"0% 0%\", \"30% 70%\", \"70% 30%\", \"100% 100%\", \"70% 30%\", \"30% 70%\", \"0% 0%\"],\n        backgroundSize: [\"350% 350%\", \"450% 450%\", \"350% 350%\", \"500% 500%\", \"350% 350%\"],\n        duration: baseSpeed * 1.4,\n      },\n      waves: {\n        backgroundPosition: [\"0% 0%\", \"100% 0%\", \"100% 100%\", \"0% 100%\", \"0% 0%\"],\n        backgroundSize: [\"500% 500%\", \"700% 700%\", \"500% 500%\"],\n        duration: baseSpeed * 0.8,\n      },\n      aurora: {\n        backgroundPosition: [\"0% 0%\", \"20% 80%\", \"80% 20%\", \"100% 100%\", \"80% 20%\", \"20% 80%\", \"0% 0%\"],\n        backgroundSize: [\"600% 600%\", \"800% 800%\", \"600% 600%\", \"900% 900%\", \"600% 600%\"],\n        duration: baseSpeed * 1.8,\n      },\n      spiral: {\n        backgroundPosition: [\"50% 50%\", \"100% 0%\", \"0% 100%\", \"100% 100%\", \"50% 50%\"],\n        backgroundSize: [\"400% 400%\", \"600% 600%\", \"400% 400%\"],\n        duration: baseSpeed * 1.3,\n      },\n      pulse: {\n        backgroundPosition: [\"50% 50%\", \"50% 50%\", \"50% 50%\"],\n        backgroundSize: [\"300% 300%\", \"800% 800%\", \"300% 300%\"],\n        duration: baseSpeed * 0.6,\n      }\n    }\n    const config = animationConfigs[animationType] || animationConfigs.mesh\n\n    return {\n      animate: {\n        ...config,\n        transition: {\n          duration: config.duration,\n          ease: \"easeInOut\",\n          repeat: Number.POSITIVE_INFINITY,\n        },\n      },\n      static: {\n        backgroundPosition: \"0% 0%\",\n        backgroundSize: \"400% 400%\",\n      },\n    }\n  }, [speed, animationType])\n\n  const grainVariants: Variants = useMemo(\n    () => ({\n      animate: {\n        opacity: [\n          grainIntensity / 100,\n          (grainIntensity / 100) * 0.7,\n          (grainIntensity / 100) * 0.4,\n          (grainIntensity / 100) * 0.9,\n          grainIntensity / 100,\n        ],\n        scale: [1, 1.02, 1.05, 1.01, 1],\n        rotate: [0, 1, -1, 0.5, 0],\n        transition: {\n          duration: 12 / speed,\n          ease: [0.25, 0.1, 0.25, 1] as const,\n          repeat: Number.POSITIVE_INFINITY,\n        },\n      },\n      static: { opacity: grainIntensity / 100, scale: 1, rotate: 0 },\n    }),\n    [grainIntensity, speed],\n  )\n  const MotionComponent = motion[as] as any\n\n  return (\n    <MotionComponent\n      ref={containerRef}\n      className={cn(\"grainy-animated-bg overflow-hidden\", className)}\n      onClick={onClick}\n      style={{\n        ...getSizeStyles(size),\n        position,\n        zIndex,\n        backgroundColor: darkMode ? \"#0a0a0a\" : \"#ffffff\",\n        pointerEvents: \"auto\",\n        isolation: \"isolate\",\n      }}\n    >\n      {/* Base gradient layer */}\n      <motion.div className=\"absolute inset-0\"\n        variants={variants}\n        animate={animate ? \"animate\" : \"static\"}\n        style={{\n          backgroundImage: gradient,\n          backgroundSize: \"400% 400%\",\n          pointerEvents: \"none\",\n          zIndex: 1,\n        }}\n      />\n\n      <motion.div className=\"absolute inset-0\"\n        variants={grainVariants}\n        animate={animate ? \"animate\" : \"static\"}\n        style={{\n          backgroundImage: `url(\"${grainSVG}\")`,\n          backgroundSize: \"256px 256px\",\n          pointerEvents: \"none\",\n          zIndex: 2,\n          mixBlendMode: \"multiply\",\n          opacity: grainIntensity / 150,\n        }}\n      />\n      <div className={`relative w-full h-full z-10 ${className}`}\n        style={{\n          pointerEvents: \"auto\",\n          position: \"relative\",\n        }}\n      >\n        {children}\n      </div>\n    </MotionComponent>\n  )\n}",
      "type": "registry:ui",
      "target": "components/ui/animated-grainy-bg.tsx"
    },
    {
      "path": "lib/utils.ts",
      "content": "import clsx, { ClassValue } from \"clsx\";\nimport { Metadata } from \"next\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function humanize(name: string): string {\n  return name\n    .replace(/-/g, \" \")\n    .replace(/([A-Z])/g, \" $1\")\n    .trim()\n    .split(/\\s+/)\n    .map((word) => word[0].toUpperCase() + word.substring(1).toLowerCase())\n    .join(\" \");\n}\n\nexport const truncate = (str: string | null, length: number) => {\n  if (!str || str.length <= length) return str;\n  return `${str.slice(0, length - 3)}...`;\n};\n\nexport const fetcher = (...args: Parameters<typeof fetch>) =>\n  fetch(...args).then((res) => res.json());\n\nexport const capitalize = (str: string, lower = false) =>\n  (lower ? str.toLowerCase() : str).replace(/(?:^|\\s|[\"'([{])+\\S/g, (match) =>\n    match.toUpperCase(),\n  );\n\nexport function formatDate(input: string | number): string {\n  const date = new Date(input);\n  return date.toLocaleDateString(\"en-US\", {\n    month: \"long\",\n    day: \"numeric\",\n    year: \"numeric\",\n  });\n}\n\nexport function absoluteUrl(path: string) {\n  return `${process.env.NEXT_PUBLIC_APP_URL || \"https://nuvyxui.vercel.app\"}${path}`;\n}\n\nexport function constructMetadata({\n  title = \"Nyx UI - Modern React + Tailwind CSS + Motion components & Templates\",\n  description = \"Nyx UI is a curated collection of the best landing page components built using React + Tailwind CSS + Motion\",\n  image = absoluteUrl(\"/og\"),\n  ...props\n}: {\n  title?: string;\n  description?: string;\n  image?: string;\n  [key: string]: Metadata[keyof Metadata];\n}): Metadata {\n  return {\n    title,\n    description,\n    keywords: [\n      \"React\",\n      \"Tailwind CSS\",\n      \"Motion\",\n      \"Landing Page\",\n      \"Components\",\n      \"Next.js\",\n    ],\n    openGraph: {\n      title,\n      description,\n      type: \"website\",\n      images: [\n        {\n          url: image,\n          width: 1200,\n          height: 630,\n        },\n      ],\n    },\n    twitter: {\n      card: \"summary_large_image\",\n      title,\n      description,\n      images: [image],\n      creator: \"@mihirjaiswal\",\n    },\n    icons: \"/favicon.ico\",\n    metadataBase: new URL(\"https://nuvyxui.vercel.app/\"),\n    authors: [\n      {\n        name: \"Mihir Jaiswal\",\n        url: \"https://github.com/MihirJaiswal\",\n      },\n    ],\n    creator: \"mihirjaiswal\",\n    ...props,\n  };\n}\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}