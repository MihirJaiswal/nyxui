{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "animated-grainy-bg",
  "type": "registry:ui",
  "title": "Animated Grainy Background",
  "description": "A dynamic animated gradient background component that supports various gradient patterns and animations.",
  "dependencies": [
    "motion",
    "motion",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/animated-grainy-bg.tsx",
      "content": "\"use client\"\nimport type React from \"react\"\nimport { useMemo } from \"react\"\nimport { motion, type Variants } from \"motion/react\"\nimport { cn } from \"@/lib/utils\"\n\nexport interface GrainyAnimatedBgProps {\n  children?: React.ReactNode\n  className?: string\n  style?: React.CSSProperties \n  colors?: string[]\n  speed?: number\n  grainType?: \"digital\" | \"plasma\" | \"scratches\" | \"paper\" | \"noise\" | \"dust\"\n  grainIntensity?: number\n  grainSize?: number\n  animationType?: \"flow\" | \"mesh\" | \"waves\" | \"aurora\" | \"spiral\" | \"pulse\"\n  size?: \"sm\" | \"md\" | \"lg\" | \"full\" | number\n  position?: \"fixed\" | \"absolute\" | \"relative\"\n  zIndex?: number\n  animate?: boolean\n  darkMode?: boolean\n  as?: \"div\" | \"section\" | \"article\" | \"main\" | \"aside\" | \"header\" | \"footer\"\n  grainBlendMode?: \"multiply\" | \"overlay\" | \"soft-light\" | \"hard-light\" | \"screen\" | \"color-burn\" | \"normal\"\n}\n\nconst getSizeStyles = (size: GrainyAnimatedBgProps[\"size\"]): React.CSSProperties => {\n  if (typeof size === \"number\") {\n    return { width: `${size}px`, height: `${size}px` }\n  }\n  const sizeMap = {\n    sm: { width: \"300px\", height: \"300px\" },\n    md: { width: \"500px\", height: \"500px\" },\n    lg: { width: \"800px\", height: \"800px\" },\n    full: { width: \"100%\", height: \"100%\" },\n  } as const\n  return sizeMap[size || \"full\"]\n}\n\nconst getGrainSVG = (\n  type: NonNullable<GrainyAnimatedBgProps[\"grainType\"]>,\n  intensity: number,\n  size: number,\n  darkMode: boolean,\n): string => {\n  const baseFreq = Math.max(0.1, size / 120)\n  const opacity = Math.min(0.95, (intensity / 100) * 1.2) \n  const lightMatrix = darkMode\n    ? \"0 0 0 0 0.9 0 0 0 0 0.9 0 0 0 0 0.9 0 0 0\" \n    : \"0 0 0 0 0.1 0 0 0 0 0.1 0 0 0 0 0.1 0 0 0\"\n\n  const grainConfigs = {\n    digital: {\n      freq: baseFreq * 1.8,\n      octaves: 3,\n      opacity: opacity * 1.5,\n      seed: 5,\n      type: \"turbulence\" as const,\n    },\n    plasma: {\n      freq: baseFreq * 0.15,\n      octaves: 12,\n      opacity: opacity * 1.1,\n      seed: 7,\n      type: \"turbulence\" as const,\n    },\n    scratches: {\n      freq: baseFreq * 0.05,\n      octaves: 2,\n      opacity: opacity * 1.8,\n      seed: 1,\n      type: \"turbulence\" as const,\n    },\n    paper: {\n      freq: baseFreq * 0.6,\n      octaves: 7,\n      opacity: opacity * 0.7,\n      seed: 4,\n      type: \"fractalNoise\" as const,\n    },\n    noise: {\n      freq: baseFreq * 2.2,\n      octaves: 4,\n      opacity: opacity * 1.4,\n      seed: 8,\n      type: \"turbulence\" as const,\n    },\n    dust: {\n      freq: baseFreq * 0.3,\n      octaves: 5,\n      opacity: opacity * 1.2,\n      seed: 6,\n      type: \"fractalNoise\" as const,\n    },\n  } as const\n\n  const config = grainConfigs[type]\n  return `data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='${type}' x='0%25' y='0%25' width='100%25' height='100%25'%3E%3CfeTurbulence type='${config.type}' baseFrequency='${config.freq}' numOctaves='${config.octaves}' seed='${config.seed}' result='noise'/%3E%3CfeColorMatrix in='noise' type='saturate' values='0' result='desaturated'/%3E%3CfeColorMatrix in='desaturated' type='matrix' values='${lightMatrix} ${config.opacity}' result='colored'/%3E%3CfeComposite in='colored' in2='SourceGraphic' operator='multiply' result='grain1'/%3E%3CfeTurbulence type='${config.type === \"turbulence\" ? \"fractalNoise\" : \"turbulence\"}' baseFrequency='${config.freq * 1.5}' numOctaves='${Math.max(1, config.octaves - 2)}' seed='${config.seed + 10}' result='noise2'/%3E%3CfeColorMatrix in='noise2' type='saturate' values='0' result='desaturated2'/%3E%3CfeColorMatrix in='desaturated2' type='matrix' values='${lightMatrix} ${config.opacity * 0.6}' result='colored2'/%3E%3CfeComposite in='grain1' in2='colored2' operator='screen' result='final'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23${type})' fill='%23${darkMode ? \"ffffff\" : \"000000\"}'/%3E%3C/svg%3E`\n}\n\nconst getGradientPattern = (\n  pattern: NonNullable<GrainyAnimatedBgProps[\"animationType\"]>,\n  colors: string[],\n  darkMode = false,\n): string => {\n  const defaultColors = darkMode\n    ? [\"#1a1a2e\", \"#16213e\", \"#0f3460\", \"#533483\"]\n    : [\"#ff6b6b\", \"#4ecdc4\", \"#45b7d1\", \"#96ceb4\"]\n\n  const finalColors = colors.length > 0 ? colors : defaultColors\n  const baseOpacity = darkMode ? \"85\" : \"75\"\n  const lightOpacity = darkMode ? \"65\" : \"55\"\n  const heavyOpacity = darkMode ? \"95\" : \"90\"\n  const ultraLightOpacity = darkMode ? \"45\" : \"35\"\n  const gradientPatterns = {\n    flow: (): string => {\n      const gradients: string[] = []\n      finalColors.forEach((color, i) => {\n        const angle = (360 / finalColors.length) * i\n        const x = 50 + Math.cos((angle * Math.PI) / 180) * 35\n        const y = 50 + Math.sin((angle * Math.PI) / 180) * 35\n        gradients.push(\n          `radial-gradient(circle at ${x}% ${y}%, ${color}${heavyOpacity} 0%, ${color}${baseOpacity} 25%, ${color}${lightOpacity} 50%, transparent 75%)`,\n        )\n      })\n      finalColors.forEach((color, i) => {\n        const offset = 180 / finalColors.length\n        const angle = (360 / finalColors.length) * i + offset\n        const x = 50 + Math.cos((angle * Math.PI) / 180) * 25\n        const y = 50 + Math.sin((angle * Math.PI) / 180) * 25\n        gradients.push(\n          `radial-gradient(ellipse 150% 100% at ${x}% ${y}%, ${color}${lightOpacity} 0%, ${color}${ultraLightOpacity} 40%, transparent 70%)`,\n        )\n      })\n\n      return gradients.join(\", \")\n    },\n\n    mesh: (): string => {\n      const gradients: string[] = []\n      const meshPoints: { x: number; y: number; color: string }[] = []\n\n      // Generate strategic mesh points\n      finalColors.forEach((color, i) => {\n        const angle = i * 137.508 \n        const radius = Math.sqrt(i + 1) * 15\n        const x = 50 + Math.cos((angle * Math.PI) / 180) * radius\n        const y = 50 + Math.sin((angle * Math.PI) / 180) * radius\n        const clampedX = Math.max(15, Math.min(85, x))\n        const clampedY = Math.max(15, Math.min(85, y))\n\n        meshPoints.push({ x: clampedX, y: clampedY, color })\n      })\n\n      // Primary mesh nodes\n      meshPoints.forEach((point, i) => {\n        const { x, y, color } = point\n        gradients.push(\n          `radial-gradient(circle at ${x}% ${y}%, ${color}${heavyOpacity} 0%, ${color}${baseOpacity} 20%, ${color}${lightOpacity} 45%, ${color}${ultraLightOpacity} 65%, transparent 85%)`,\n        )\n      })\n      meshPoints.forEach((point1, i) => {\n        meshPoints.forEach((point2, j) => {\n          if (i < j) {\n            const distance = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2))\n            if (distance < 45) {\n              const angle = (Math.atan2(point2.y - point1.y, point2.x - point1.x) * 180) / Math.PI\n              gradients.push(\n                `linear-gradient(${angle}deg, ${point1.color}${ultraLightOpacity} 0%, ${point2.color}${ultraLightOpacity} 100%)`,\n              )\n            }\n          }\n        })\n      })\n\n      return gradients.join(\", \")\n    },\n\n    waves: (): string => {\n      const gradients: string[] = []\n      finalColors.forEach((color, i) => {\n        const waveOffset = ((i * 720) / finalColors.length) % 360\n        const x = 50 + Math.sin((waveOffset * Math.PI) / 180) * 45\n        const y = (i / Math.max(finalColors.length - 1, 1)) * 100\n        gradients.push(\n          `radial-gradient(ellipse 400% 60% at ${x}% ${y}%, ${color}${heavyOpacity} 0%, ${color}${baseOpacity} 30%, ${color}${lightOpacity} 60%, transparent 80%)`,\n        )\n      })\n      // Vertical waves\n      finalColors.forEach((color, i) => {\n        const waveOffset = (i * 540) / finalColors.length + 90\n        const y = 50 + Math.cos((waveOffset * Math.PI) / 180) * 40\n        const x = (i / Math.max(finalColors.length - 1, 1)) * 100\n        gradients.push(\n          `radial-gradient(ellipse 60% 300% at ${x}% ${y}%, ${color}${baseOpacity} 0%, ${color}${lightOpacity} 35%, transparent 65%)`,\n        )\n      })\n\n      return gradients.join(\", \")\n    },\n\n    aurora: (): string => {\n      const gradients: string[] = []\n      finalColors.forEach((color, i) => {\n        const curtainAngle = 88 + (i * 6) / finalColors.length - 3\n        const intensity = i % 2 === 0 ? heavyOpacity : baseOpacity\n\n        gradients.push(`linear-gradient(${curtainAngle}deg,\n          transparent 0%,\n          ${color}${ultraLightOpacity} 10%,\n          ${color}${lightOpacity} 20%,\n          ${color}${baseOpacity} 35%,\n          ${color}${intensity} 50%,\n          ${color}${baseOpacity} 65%,\n          ${color}${lightOpacity} 80%,\n          ${color}${ultraLightOpacity} 90%,\n          transparent 100%)`)\n      })\n\n      // Aurora waves\n      finalColors.forEach((color, i) => {\n        const waveY = 15 + (i * 70) / finalColors.length\n        gradients.push(`radial-gradient(ellipse 1000% 30% at 50% ${waveY}%,\n          ${color}${baseOpacity} 0%,\n          ${color}${lightOpacity} 20%,\n          ${color}${ultraLightOpacity} 40%,\n          transparent 70%)`)\n      })\n      return gradients.join(\", \")\n    },\n\n    spiral: (): string => {\n      const gradients: string[] = []\n      finalColors.forEach((color, i) => {\n        const spiralAngle = (i * 360) / finalColors.length + i * 60\n        const radius = 15 + (i * 20) / finalColors.length\n        const x = 50 + Math.cos((spiralAngle * Math.PI) / 180) * radius\n        const y = 50 + Math.sin((spiralAngle * Math.PI) / 180) * radius\n        gradients.push(\n          `radial-gradient(circle at ${x}% ${y}%, ${color}${heavyOpacity} 0%, ${color}${baseOpacity} 30%, ${color}${lightOpacity} 60%, transparent 80%)`,\n        )\n      })\n      // Counter spiral\n      finalColors.forEach((color, i) => {\n        const spiralAngle = -((i * 360) / finalColors.length) + i * 45\n        const radius = 10 + (i * 15) / finalColors.length\n        const x = 50 + Math.cos((spiralAngle * Math.PI) / 180) * radius\n        const y = 50 + Math.sin((spiralAngle * Math.PI) / 180) * radius\n        gradients.push(\n          `radial-gradient(ellipse 120% 80% at ${x}% ${y}%, ${color}${lightOpacity} 0%, ${color}${ultraLightOpacity} 50%, transparent 75%)`,\n        )\n      })\n      return gradients.join(\", \")\n    },\n\n    pulse: (): string => {\n      const gradients: string[] = []\n      // Concentric pulses\n      finalColors.forEach((color, i) => {\n        const ringRadius = 15 + (i * 70) / finalColors.length\n        gradients.push(`radial-gradient(circle at 50% 50%, \n          transparent ${ringRadius - 15}%, \n          ${color}${lightOpacity} ${ringRadius - 5}%,\n          ${color}${heavyOpacity} ${ringRadius}%, \n          ${color}${baseOpacity} ${ringRadius + 5}%,\n          ${color}${lightOpacity} ${ringRadius + 15}%,\n          transparent ${ringRadius + 25}%)`)\n      })\n\n      // Pulse nodes\n      finalColors.forEach((color, i) => {\n        const angle = (i * 360) / finalColors.length\n        const x = 50 + Math.cos((angle * Math.PI) / 180) * 25\n        const y = 50 + Math.sin((angle * Math.PI) / 180) * 25\n        gradients.push(\n          `radial-gradient(circle at ${x}% ${y}%, ${color}${heavyOpacity} 0%, ${color}${baseOpacity} 25%, ${color}${lightOpacity} 50%, transparent 75%)`,\n        )\n      })\n\n      return gradients.join(\", \")\n    },\n  } as const\n  return gradientPatterns[pattern]()\n}\n\nconst defaultColors = {\n  light: [\"#ff6b6b\", \"#4ecdc4\", \"#45b7d1\", \"#96ceb4\"],\n  dark: [\"#1a1a2e\", \"#16213e\", \"#0f3460\", \"#533483\"],\n}\n\nexport const AnimatedGrainyBg: React.FC<GrainyAnimatedBgProps> = ({\n  children,\n  className,\n  style,  \n  colors,\n  speed = 1,\n  grainType = \"digital\",\n  grainIntensity = 60, \n  grainSize = 100, \n  animationType = \"mesh\",\n  size = \"full\",\n  position = \"relative\",\n  zIndex = 0,\n  animate = true,\n  darkMode = false,\n  as = \"div\",\n  grainBlendMode = \"soft-light\", \n}) => {\n  const finalColors = colors || defaultColors[darkMode ? \"dark\" : \"light\"]\n  const gradient = useMemo(\n    () => getGradientPattern(animationType, finalColors, darkMode),\n    [animationType, finalColors, darkMode],\n  )\n  const grainSVG = useMemo(\n    () => getGrainSVG(grainType, grainIntensity, grainSize, darkMode),\n    [grainType, grainIntensity, grainSize, darkMode],\n  )\n\n  const variants: Variants = useMemo(() => {\n    const baseSpeed = 25 / speed\n    const animationConfigs = {\n      flow: {\n        backgroundPosition: [\"0% 0%\", \"100% 100%\", \"0% 100%\", \"100% 0%\", \"0% 0%\"],\n        backgroundSize: [\"400% 400%\", \"600% 600%\", \"400% 400%\"],\n        duration: baseSpeed,\n      },\n      mesh: {\n        backgroundPosition: [\"0% 0%\", \"15% 35%\", \"35% 15%\", \"50% 50%\", \"35% 15%\", \"15% 35%\", \"0% 0%\"], // Reduced movement\n        backgroundSize: [\"350% 350%\", \"400% 400%\", \"350% 350%\"], // Less dramatic size changes\n        duration: baseSpeed * 1.5,\n      },\n      waves: {\n        backgroundPosition: [\"0% 0%\", \"100% 0%\", \"100% 100%\", \"0% 100%\", \"0% 0%\"],\n        backgroundSize: [\"500% 500%\", \"700% 700%\", \"500% 500%\"],\n        duration: baseSpeed * 0.9,\n      },\n      aurora: {\n        backgroundPosition: [\"0% 0%\", \"20% 80%\", \"80% 20%\", \"100% 100%\", \"80% 20%\", \"20% 80%\", \"0% 0%\"],\n        backgroundSize: [\"600% 600%\", \"900% 900%\", \"600% 600%\"],\n        duration: baseSpeed * 2,\n      },\n      spiral: {\n        backgroundPosition: [\"50% 50%\", \"100% 0%\", \"0% 100%\", \"100% 100%\", \"50% 50%\"],\n        backgroundSize: [\"400% 400%\", \"650% 650%\", \"400% 400%\"],\n        duration: baseSpeed * 1.4,\n      },\n      pulse: {\n        backgroundPosition: [\"50% 50%\", \"50% 50%\", \"50% 50%\"],\n        backgroundSize: [\"300% 300%\", \"900% 900%\", \"300% 300%\"],\n        duration: baseSpeed * 0.7,\n      },\n    }\n    const config = animationConfigs[animationType] || animationConfigs.mesh\n    return {\n      animate: {\n        ...config,\n        transition: {\n          duration: config.duration,\n          ease: \"easeInOut\",\n          repeat: Number.POSITIVE_INFINITY,\n        },\n      },\n      static: {\n        backgroundPosition: \"0% 0%\",\n        backgroundSize: \"400% 400%\",\n      },\n    }\n  }, [speed, animationType])\n\n  const grainVariants: Variants = useMemo(\n    () => ({\n      animate: {\n        opacity: [\n          grainIntensity / 100,\n          (grainIntensity / 100) * 0.8,\n          (grainIntensity / 100) * 0.6,\n          (grainIntensity / 100) * 0.9,\n          grainIntensity / 100,\n        ],\n        scale: [1, 1.01, 1.02, 1.01, 1], \n        transition: {\n          duration: 8 / speed,\n          ease: [0.25, 0.1, 0.25, 1] as const,\n          repeat: Number.POSITIVE_INFINITY,\n        },\n      },\n      static: { opacity: grainIntensity / 100, scale: 1 },\n    }),\n    [grainIntensity, speed],\n  )\n\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const MotionComponent = motion[as] as any\n\n  return (\n    <MotionComponent\n      className={cn(\"enhanced-grainy-animated-bg overflow-hidden\", className)}\n      style={{\n        ...getSizeStyles(size),\n        ...style, \n        position,\n        zIndex,\n        backgroundColor: darkMode ? \"#0a0a0a\" : \"#ffffff\",\n        pointerEvents: \"auto\",\n        isolation: \"isolate\",\n      }}\n    >\n      {/* Base gradient layer */}\n      <motion.div\n        className=\"absolute inset-0\"\n        variants={variants}\n        animate={animate ? \"animate\" : \"static\"}\n        style={{\n          backgroundImage: gradient,\n          backgroundSize: \"400% 400%\",\n          pointerEvents: \"none\",\n          zIndex: 1,\n        }}\n      />\n\n      {/* Primary grain layer */}\n      <motion.div\n        className=\"absolute inset-0\"\n        variants={grainVariants}\n        animate={animate ? \"animate\" : \"static\"}\n        style={{\n          backgroundImage: `url(\"${grainSVG}\")`,\n          backgroundSize: `${grainSize * 2}px ${grainSize * 2}px`,\n          pointerEvents: \"none\",\n          zIndex: 2,\n          mixBlendMode: grainBlendMode,\n          opacity: Math.min(0.8, grainIntensity / 100),\n        }}\n      />\n      {/* Content layer */}\n      <div\n        className=\"relative w-full h-full z-10\"\n        style={{\n          pointerEvents: \"auto\",\n          position: \"relative\",\n        }}\n      >\n        {children}\n      </div>\n    </MotionComponent>\n  )\n}",
      "type": "registry:ui",
      "target": "components/ui/animated-grainy-bg.tsx"
    },
    {
      "path": "lib/utils.ts",
      "content": "import clsx, { ClassValue } from \"clsx\";\nimport { Metadata } from \"next\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function humanize(name: string): string {\n  return name\n    .replace(/-/g, \" \")\n    .replace(/([A-Z])/g, \" $1\")\n    .trim()\n    .split(/\\s+/)\n    .map((word) => word[0].toUpperCase() + word.substring(1).toLowerCase())\n    .join(\" \");\n}\n\nexport const truncate = (str: string | null, length: number) => {\n  if (!str || str.length <= length) return str;\n  return `${str.slice(0, length - 3)}...`;\n};\n\nexport const fetcher = (...args: Parameters<typeof fetch>) =>\n  fetch(...args).then((res) => res.json());\n\nexport const capitalize = (str: string, lower = false) =>\n  (lower ? str.toLowerCase() : str).replace(/(?:^|\\s|[\"'([{])+\\S/g, (match) =>\n    match.toUpperCase(),\n  );\n\nexport function formatDate(input: string | number): string {\n  const date = new Date(input);\n  return date.toLocaleDateString(\"en-US\", {\n    month: \"long\",\n    day: \"numeric\",\n    year: \"numeric\",\n  });\n}\n\nexport function absoluteUrl(path: string) {\n  return `${process.env.NEXT_PUBLIC_APP_URL || \"https://nyxui.vercel.app\"}${path}`;\n}\n\nexport function constructMetadata({\n  title = \"Nyx UI - Modern React + Tailwind CSS + Motion components & Templates\",\n  description = \"Nyx UI is a curated collection of the best landing page components built using React + Tailwind CSS + Motion\",\n  image = absoluteUrl(\"/og\"),\n  ...props\n}: {\n  title?: string;\n  description?: string;\n  image?: string;\n  [key: string]: Metadata[keyof Metadata];\n}): Metadata {\n  return {\n    title,\n    description,\n    keywords: [\n      \"React\",\n      \"Tailwind CSS\",\n      \"Motion\",\n      \"Landing Page\",\n      \"Components\",\n      \"Next.js\",\n    ],\n    openGraph: {\n      title,\n      description,\n      type: \"website\",\n      images: [\n        {\n          url: image,\n          width: 1200,\n          height: 630,\n        },\n      ],\n    },\n    twitter: {\n      card: \"summary_large_image\",\n      title,\n      description,\n      images: [image],\n      creator: \"@mihirjaiswal\",\n    },\n    icons: \"/favicon.ico\",\n    metadataBase: new URL(\"https://nyxui.vercel.app/\"),\n    authors: [\n      {\n        name: \"Mihir Jaiswal\",\n        url: \"https://github.com/MihirJaiswal\",\n      },\n    ],\n    creator: \"mihirjaiswal\",\n    ...props,\n  };\n}\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}